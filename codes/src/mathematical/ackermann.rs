use crate::{errors::CodeError, traits::Code};

// f({}) = 0
// f(A) = sum 2^f(elem_i) for all elem_i in A
// implies

// f({{}}) = 2^0 = 1
// f({{{}}}) = 2^f({{}}) = 2^1 = 2
// f({{}{{}}}) = 2^f({}) + 2^f({{}}) = 2^0 + 2^1 = 1 + 2 = 3
// f({{{{}}}}) = 2^f({{{}}}) = 2^2 = 4
// f({{}{{{}}}}) = 2^f({}) + 2^f({{{}}}) = 2^0 + 2^2 = 5
// f({{{}}{{{}}}}) = 2^f({{}}) + 2^f({{{}}}) = 2^1 + 2^2 = 6
// f({{}{{}}{{{}}}}) = 2^f({}) = 2^f({{}}) + 2^f({{{}}}) = 2^0 + 2^1 + 2^2 = 7
// f({{{}{{}}})}) = 2^3 = 8
// f({{{{{}}}}}) = 2^f({{{{}}}}) = 2^4 = 16

const SMALL_SETS: [&str; 32] = [
    "{}",
    "{{}}",
    "{{{}}}",
    "{{}{{}}}",
    "{{{{}}}}",
    "{{}{{{}}}}",
    "{{{}}{{{}}}}",
    "{{}{{}}{{{}}}}",
    "{{{}{{}}}}",
    "{{}{{}{{}}}}",
    "{{{}}{{}{{}}}}",
    "{{}{{}}{{}{{}}}}",
    "{{{{}}}{{}{{}}}}",
    "{{}{{{}}}{{}{{}}}}",
    "{{{}}{{{}}}{{}{{}}}}",
    "{{}{{}}{{{}}}{{}{{}}}}",
    "{{{{{}}}}}",
    "{{}{{{{}}}}}",
    "{{{}}{{{{}}}}}",
    "{{}{{}}{{{{}}}}}",
    "{{{{}}}{{{{}}}}}",
    "{{}{{{}}}{{{{}}}}}",
    "{{{}}{{{}}}{{{{}}}}}",
    "{{}{{}}{{{}}}{{{{}}}}}",
    "{{{}{{}}}{{{{}}}}}",
    "{{}{{}{{}}}{{{{}}}}}",
    "{{{}}{{}{{}}}{{{{}}}}}",
    "{{}{{}}{{}{{}}}{{{{}}}}}",
    "{{{{}}}{{}{{}}}{{{{}}}}}",
    "{{}{{{}}}{{}{{}}}{{{{}}}}}",
    "{{{}}{{{}}}{{}{{}}}{{{{}}}}}",
    "{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}",
];

pub fn number_to_set(mut n: u32) -> String {
    let mut out = String::from("{");
    for i in 0..=32 {
        if n & 1 == 1 {
            // out.push_str(&number_to_set(i));
            out.push_str(SMALL_SETS[i]); // faster than recursion
        }
        n >>= 1;
    }
    out.push('}');
    out
}

pub fn paren_ranges_nonoverlapping_subsets(s: &str) -> Result<Vec<(usize, usize)>, CodeError> {
    let mut starts = Vec::new();
    let mut pairs: Vec<(usize, usize)> = Vec::new();

    for (i, c) in s.chars().enumerate() {
        if c == '{' {
            starts.push(i);
        } else if c == '}' {
            if starts.is_empty() {
                return Err(CodeError::input("brackets in the set do not match"));
            } else {
                let pair = (starts.pop().unwrap(), i + 1);
                if pair.0 == 0 {
                    break;
                }
                pairs.retain(|x| x.0 < pair.0 && x.1 < pair.1);
                pairs.push(pair);
            }
        } else {
            return Err(CodeError::input("invalid character"));
        }
    }

    Ok(pairs)
}

pub struct Ackermann {}

impl Default for Ackermann {
    fn default() -> Self {
        Self {}
    }
}

impl Code for Ackermann {
    fn encode(&self, text: &str) -> Result<String, CodeError> {
        let mut out = Vec::new();
        for num in text.split(",") {
            match u32::from_str_radix(num.trim(), 10) {
                Ok(n) => {
                    out.push(number_to_set(n));
                }
                Err(_) => out.push(String::from("INVALID")),
            }
        }
        Ok(out.join(", "))
    }

    fn decode(&self, text: &str) -> Result<String, CodeError> {
        let mut out = Vec::new();
        for set in text.split(",").map(|s| s.trim()) {
            let mut n = 0;
            let ranges = paren_ranges_nonoverlapping_subsets(set)?;
            for range in ranges {
                n += 1_u32
                    << SMALL_SETS
                        .iter()
                        .position(|x| *x == &set[range.0..range.1])
                        .unwrap();
            }
            out.push(n.to_string());
        }
        Ok(out.join(", "))
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[test]
    fn encode_test() {
        let code = Ackermann::default();
        assert_eq!(                                                                                                              
            "{}, {{}}, {{{}}}, {{}{{}}}, {{{{}}}}, {{}{{{}}}}, {{{}}{{{}}}}, {{}{{}}{{{}}}}, {{{}{{}}}}, {{}{{}{{}}}}, {{{{{}}}}}, {{}{{}{{{}}}}}, {{}{{}}{{{}}}{{}{{}}}{{{{}}}}{{}{{{}}}}{{{}}{{{}}}}{{}{{}}{{{}}}}{{{}{{}}}}{{}{{}{{}}}}{{{}}{{}{{}}}}{{}{{}}{{}{{}}}}{{{{}}}{{}{{}}}}{{}{{{}}}{{}{{}}}}{{{}}{{{}}}{{}{{}}}}{{}{{}}{{{}}}{{}{{}}}}{{{{{}}}}}{{}{{{{}}}}}{{{}}{{{{}}}}}{{}{{}}{{{{}}}}}{{{{}}}{{{{}}}}}{{}{{{}}}{{{{}}}}}{{{}}{{{}}}{{{{}}}}}{{}{{}}{{{}}}{{{{}}}}}{{{}{{}}}{{{{}}}}}{{}{{}{{}}}{{{{}}}}}{{{}}{{}{{}}}{{{{}}}}}{{}{{}}{{}{{}}}{{{{}}}}}{{{{}}}{{}{{}}}{{{{}}}}}{{}{{{}}}{{}{{}}}{{{{}}}}}{{{}}{{{}}}{{}{{}}}{{{{}}}}}{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}}",
            code.encode("0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 33, 4294967295").unwrap()
        )
    }

    #[test]
    fn decode_test() {
        let code = Ackermann::default();
        assert_eq!("0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 33, 4294967295", code.decode("{}, {{}}, {{{}}}, {{}{{}}}, {{{{}}}}, {{}{{{}}}}, {{{}}{{{}}}}, {{}{{}}{{{}}}}, {{{}{{}}}}, {{}{{}{{}}}}, {{{{{}}}}}, {{}{{}{{{}}}}}, {{}{{}}{{{}}}{{}{{}}}{{{{}}}}{{}{{{}}}}{{{}}{{{}}}}{{}{{}}{{{}}}}{{{}{{}}}}{{}{{}{{}}}}{{{}}{{}{{}}}}{{}{{}}{{}{{}}}}{{{{}}}{{}{{}}}}{{}{{{}}}{{}{{}}}}{{{}}{{{}}}{{}{{}}}}{{}{{}}{{{}}}{{}{{}}}}{{{{{}}}}}{{}{{{{}}}}}{{{}}{{{{}}}}}{{}{{}}{{{{}}}}}{{{{}}}{{{{}}}}}{{}{{{}}}{{{{}}}}}{{{}}{{{}}}{{{{}}}}}{{}{{}}{{{}}}{{{{}}}}}{{{}{{}}}{{{{}}}}}{{}{{}{{}}}{{{{}}}}}{{{}}{{}{{}}}{{{{}}}}}{{}{{}}{{}{{}}}{{{{}}}}}{{{{}}}{{}{{}}}{{{{}}}}}{{}{{{}}}{{}{{}}}{{{{}}}}}{{{}}{{{}}}{{}{{}}}{{{{}}}}}{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}}").unwrap())
    }
}
