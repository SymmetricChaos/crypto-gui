use utils::{errors::GeneralError, bracket_matching::paren_ranges_nonoverlapping_subsets};

use crate::{ traits::Code};

// f({}) = 0
// f(A) = sum 2^f(elem_i) for all elem_i in A
// implies

// f({{}}) = 2^0 = 1
// f({{{}}}) = 2^f({{}}) = 2^1 = 2
// f({{}{{}}}) = 2^f({}) + 2^f({{}}) = 2^0 + 2^1 = 1 + 2 = 3
// f({{{{}}}}) = 2^f({{{}}}) = 2^2 = 4
// f({{}{{{}}}}) = 2^f({}) + 2^f({{{}}}) = 2^0 + 2^2 = 5
// f({{{}}{{{}}}}) = 2^f({{}}) + 2^f({{{}}}) = 2^1 + 2^2 = 6
// f({{}{{}}{{{}}}}) = 2^f({}) = 2^f({{}}) + 2^f({{{}}}) = 2^0 + 2^1 + 2^2 = 7
// f({{{}{{}}})}) = 2^3 = 8
// f({{{{{}}}}}) = 2^f({{{{}}}}) = 2^4 = 16

// For 32-bit numbers only these 32 sets are used, each effectively represents a particular bit
pub const BASE_SETS: [&str; 32] = [
    "{}",
    "{{}}",
    "{{{}}}",
    "{{}{{}}}",
    "{{{{}}}}",
    "{{}{{{}}}}",
    "{{{}}{{{}}}}",
    "{{}{{}}{{{}}}}",
    "{{{}{{}}}}",
    "{{}{{}{{}}}}",
    "{{{}}{{}{{}}}}",
    "{{}{{}}{{}{{}}}}",
    "{{{{}}}{{}{{}}}}",
    "{{}{{{}}}{{}{{}}}}",
    "{{{}}{{{}}}{{}{{}}}}",
    "{{}{{}}{{{}}}{{}{{}}}}",
    "{{{{{}}}}}",
    "{{}{{{{}}}}}",
    "{{{}}{{{{}}}}}",
    "{{}{{}}{{{{}}}}}",
    "{{{{}}}{{{{}}}}}",
    "{{}{{{}}}{{{{}}}}}",
    "{{{}}{{{}}}{{{{}}}}}",
    "{{}{{}}{{{}}}{{{{}}}}}",
    "{{{}{{}}}{{{{}}}}}",
    "{{}{{}{{}}}{{{{}}}}}",
    "{{{}}{{}{{}}}{{{{}}}}}",
    "{{}{{}}{{}{{}}}{{{{}}}}}",
    "{{{{}}}{{}{{}}}{{{{}}}}}",
    "{{}{{{}}}{{}{{}}}{{{{}}}}}",
    "{{{}}{{{}}}{{}{{}}}{{{{}}}}}",
    "{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}",
];

pub fn number_to_set(mut n: u32) -> String {
    let mut out = String::from("{");
    for i in 0..=32 {
        if n & 1 == 1 {
            // out.push_str(&number_to_set(i));
            out.push_str(BASE_SETS[i]); // much faster than recursion
        }
        n >>= 1;
    }
    out.push('}');
    out
}

pub fn set_to_number(s: &str) -> Result<u32,GeneralError> {
    let mut n = 0;
    for range in paren_ranges_nonoverlapping_subsets(s,'{', '}')? {
        n += 1_u32
            << BASE_SETS
                .iter()
                .position(|x| *x == &s[range.clone()])
                .unwrap();
    }
    Ok(n)
}


pub struct Ackermann {}

impl Default for Ackermann {
    fn default() -> Self {
        Self {}
    }
}

impl Code for Ackermann {
    fn encode(&self, text: &str) -> Result<String, GeneralError> {
        let mut out = Vec::new();
        for num in text.split(",") {
            match u32::from_str_radix(num.trim(), 10) {
                Ok(n) => {
                    out.push(number_to_set(n));
                }
                Err(_) => out.push(String::from("INVALID")),
            }
        }
        Ok(out.join(", "))
    }

    fn decode(&self, text: &str) -> Result<String, GeneralError> {
        let mut out = Vec::new();
        for set in text.split(",").map(|s| s.trim()) {
            out.push(set_to_number(set)?.to_string());
        }
        Ok(out.join(", "))
    }
}

#[cfg(test)]
mod tests {

    use super::*;

    #[ignore = "constant generation"]
    #[test]
    fn generate_base_sets() {
        println!("pub const BASE_SETS: [&str; 32] = [");
        for i in 0..32 {
            println!("    \"{}\",",number_to_set(i))
        }
        println!("];");
    }

    #[test]
    fn encode_decode() {
        for i in 0..1_000_000 {
            let s = number_to_set(i);
            assert_eq!(i,set_to_number(&s).unwrap())
        }
    }

    #[test]
    fn encode_test() {
        let code = Ackermann::default();
        assert_eq!(                                                                                                              
            "{}, {{}}, {{{}}}, {{}{{}}}, {{{{}}}}, {{}{{{}}}}, {{{}}{{{}}}}, {{}{{}}{{{}}}}, {{{}{{}}}}, {{}{{}{{}}}}, {{{{{}}}}}, {{}{{}{{{}}}}}, {{}{{}}{{{}}}{{}{{}}}{{{{}}}}{{}{{{}}}}{{{}}{{{}}}}{{}{{}}{{{}}}}{{{}{{}}}}{{}{{}{{}}}}{{{}}{{}{{}}}}{{}{{}}{{}{{}}}}{{{{}}}{{}{{}}}}{{}{{{}}}{{}{{}}}}{{{}}{{{}}}{{}{{}}}}{{}{{}}{{{}}}{{}{{}}}}{{{{{}}}}}{{}{{{{}}}}}{{{}}{{{{}}}}}{{}{{}}{{{{}}}}}{{{{}}}{{{{}}}}}{{}{{{}}}{{{{}}}}}{{{}}{{{}}}{{{{}}}}}{{}{{}}{{{}}}{{{{}}}}}{{{}{{}}}{{{{}}}}}{{}{{}{{}}}{{{{}}}}}{{{}}{{}{{}}}{{{{}}}}}{{}{{}}{{}{{}}}{{{{}}}}}{{{{}}}{{}{{}}}{{{{}}}}}{{}{{{}}}{{}{{}}}{{{{}}}}}{{{}}{{{}}}{{}{{}}}{{{{}}}}}{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}}",
            code.encode("0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 33, 4294967295").unwrap()
        )
    }

    #[test]
    fn decode_test() {
        let code = Ackermann::default();
        assert_eq!("0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 16, 33, 4294967295", code.decode("{}, {{}}, {{{}}}, {{}{{}}}, {{{{}}}}, {{}{{{}}}}, {{{}}{{{}}}}, {{}{{}}{{{}}}}, {{{}{{}}}}, {{}{{}{{}}}}, {{{{{}}}}}, {{}{{}{{{}}}}}, {{}{{}}{{{}}}{{}{{}}}{{{{}}}}{{}{{{}}}}{{{}}{{{}}}}{{}{{}}{{{}}}}{{{}{{}}}}{{}{{}{{}}}}{{{}}{{}{{}}}}{{}{{}}{{}{{}}}}{{{{}}}{{}{{}}}}{{}{{{}}}{{}{{}}}}{{{}}{{{}}}{{}{{}}}}{{}{{}}{{{}}}{{}{{}}}}{{{{{}}}}}{{}{{{{}}}}}{{{}}{{{{}}}}}{{}{{}}{{{{}}}}}{{{{}}}{{{{}}}}}{{}{{{}}}{{{{}}}}}{{{}}{{{}}}{{{{}}}}}{{}{{}}{{{}}}{{{{}}}}}{{{}{{}}}{{{{}}}}}{{}{{}{{}}}{{{{}}}}}{{{}}{{}{{}}}{{{{}}}}}{{}{{}}{{}{{}}}{{{{}}}}}{{{{}}}{{}{{}}}{{{{}}}}}{{}{{{}}}{{}{{}}}{{{{}}}}}{{{}}{{{}}}{{}{{}}}{{{{}}}}}{{}{{}}{{{}}}{{}{{}}}{{{{}}}}}}").unwrap())
    }
}
