{
  "A5/1": {
    "Description": "The A5/1 stream cipher was created in the late 1980s for cellular telephones. The algorithm works be using three LFSRs that mutually control their stepping by majority vote of their middle bits. Although originally a secret algorithm A5/1 was reverse engineered and found to be quite weak. The output is produced in bursts of 228 bits though only the first 114 are used for encryption.",
    "Authors": null,
    "Publication": "1987",
    "Traits": [
      "Stream Cipher",
      "Cryptographic",
      "Broken"
    ]
  },
  "A5/2": {
    "Description": "The A5/2 stream cipher was created as a \"export grade\" version of the A5/1 cipher. It is interally similar to A5/1 but with modifications that drastically weaken it. When the algorithm was reverse engineered and analyzed it proved so weak that A5/2 was banned. The output is produced in bursts of 228 bits though only the first 114 are used for encryption.",
    "Authors": null,
    "Publication": "1989",
    "Traits": [
      "Stream Cipher",
      "Cryptographic",
      "Broken"
    ]
  },
  "Alternating Step Generator": {
    "Description": "An alternating step generator uses three LFSRs to produce a more secure stream of bits. The first LFSR is stepped and its output selects one of the others to be stepped. Then the last output bit from each of the other LSFRs are XORed together.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Blum-Blum-Shub": {
    "Description": "The Blum-Blum-Shub algorithm uses a simple recurrence to produce cryptographic quality pseudorandom numbers. The state is advanced by squaring it and reducing the result modulo a large semiprime. The parity of the state is used to produce a single bit, as a result the algorithm runs much more slowly than other PRNGs. Speed can be increased by using other techniques to extract more bits but at the cost of making it easier to determine the state.",
    "Authors": "Lenore Blum, Manuel Blum, and Michael Shub",
    "Publication": "1986",
    "Traits": [
      "Cryptographic"
    ]
  },
  "ChaCha": {
    "Description": "The ChaCha family of stream ciphers are, by definition, also cryptographically secure PRNGs.",
    "Authors": "Bernstein",
    "Publication": "2005",
    "Traits": [
      "Stream Cipher",
      "Cryptographic"
    ]
  },
  "Dual_EC_DRBG": {
    "Description": "Dual Elliptic Curve Deterministic Random Bit Generator is a CSPRNG most famous for being likely compromised by the NSA. It consists of an elliptic curve over a prime finite field of about 256 bits, two constant points on the curve (P and Q), and state that is an element of the prime field. The state is updated by multiplying P by the state and extracting the x-coordinate. Random numbers are generated by multiplying Q by the state, extracting the x-coordinate, and taking the lower bits.",
    "Authors": "NIST",
    "Publication": "2012",
    "Traits": [
      "Cryptographic",
      "Compromised,"
    ]
  },
  "Geffe": {
    "Description": "The Geffe generator is a (now broken) cryptographic PRNG that works by linking three LFSRs together via a multiplexer. All three are stepped together, and thus should be a coprime lengths, then the output bit of LFSR-1 selects which of the other two will give the output.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based",
      "Cryptographic",
      "Broken"
    ]
  },
  "Galois Linear Feedback Shift Register": {
    "Description": "A GLFSR works on the same principle as an LFSR but rather than XORing the taps together to create a new bit instead the last bit of the register is XORed into each tap before the shift.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Generalized Multiply-with-Carry": {
    "Description": ".",
    "Authors": "Mark Goresky and Andrew Klapper",
    "Publication": 2003,
    "Traits": [
      "LCG-based"
    ]
  },
  "Halton Sequence": {
    "Description": "The Halton sequence produces tuples of rational numbers between 0 and 1 distributed across any number of dimensions.",
    "Authors": null,
    "Publication": null,
    "Traits": null
  },
  "ISAAC": {
    "Description": "ISAAC (Indirection, Shift, Accumulate, Add, and Count) is a cryptographic PRNG probably best known for its used in the classic roguelike game NetHack.",
    "Authors": "Robert Jenkins",
    "Publication": "1993",
    "Traits": [
      "Cryptographic"
    ]
  },
  "JSF": {
    "Description": "The Jenkins Small Fast PRNG is a small, simple, and fast running algorithm that performs well on statistical tests of randomness but is not believed to be secure.",
    "Authors": "Robert Jenkins",
    "Publication": null,
    "Traits": null
  },
  "Lagged Fibonacci Generator": {
    "Description": "An LFG uses a generalized Fibonacci sequence to generate pseudorandom numbers. They are similar to a Linear Feedback Shift Register operating on numbers rather than bits and like LFSRs selection of parameters has a very strong influence on the quality of the output. A particular kind of LFG was used as part of the VIC cipher from the Cold War.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Linear Congruential Generator": {
    "Description": "LCGs are among the simplest forms of pseduorandom number generators using the well known arithmetic operations of multiplication, addition, and division. At each step the current state is multiplied by a constant, then has a constant added, and finally is divided by a constant and the remainder taken. The increment must be coprime to the modulus and the multiplier must be greater than one. LCGs and their generalizations, the Polynomial Congruential Generators, are all known to be insecure.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LCG-based"
    ]
  },
  "Linear Feedback Shift Register": {
    "Description": "LFRSs are simple pseudorandom number generators that can be implented very easily and efficiently in hardware. It consists of a register of bits and several \"taps\" that check the state of certain bits. The values of those taps are combined to determine a new bit. The rest of the bits are then shifted to accomodate the new bit and the oldest bit is discarded. The maximum period of an LFSR is achieved only when the taps correspond to a primitive polynomial.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Mersenne Twister": {
    "Description": "The Mersenne Twister (MT19937) algorithm was created in 1997 by Makoto Matsumoto and Takuji Nishimura with the goal of correcting the shortcomings of then popular PRNGs and was quickly achieved widespread adoption. In particular it is equidistributed in 623 dimensions and has a period of 2^19937-1. The major limitation of MT19937 is its enormous state of 8448 bits, modern PRNGs of comprable quality commonly use 256 bits or less of state. This huge state means that MT19937 cannot be run on small devices and is more difficult to run in parallel. The state size also makes initialization difficult, requiring either a complex key scheduling algorithm to make a key from a single word or a few words or providing 8448 bits. Because the tempering function applied on output (used to achieve equidistribution in high dimensions) is invertible and fixed it is trivial to recover the entire state, making MT19937 inappropriate for cryptographic purposes. A variant MT19937-64 was created for 64-bit computers, it uses the same structure but with slightly different constants.",
    "Authors": "Matsumoto and Nishimura",
    "Publication": "1997",
    "Traits": [
      "LFSR-based"
    ]
  },
  "Middle Square": {
    "Description": "The middle square method produces random numbers of a given width, padded on the left with zeroes, by squaring a value and then taking the middle digits as the next value. The quality of these sequences is very low and often falls quickly into short repeating sequences.",
    "Authors": "von Neumann",
    "Publication": "1949",
    "Traits": null
  },
  "Middle Square Binary": {
    "Description": "While the middle square method can be calculated by hand it is also a possible computer PRNG. When doing this on on modern computer hardware performance is much increased by specifiying the state size in bits (as this allows the middle bits to be extracted with a shift and mask) and to choose a state not more than half the size of the CPU register (as this prevents overflow when squaring). Mathematically these is no difference between these PRNGs and the other middle square PRNG defined on this site so quality is low and depends almost entirely on the size of the state space.",
    "Authors": null,
    "Publication": null,
    "Traits": null
  },
  "Multiply-with-Carry": {
    "Description": ".",
    "Authors": "George Marsaglia",
    "Publication": null,
    "Traits": null
  },
  "Naor-Reingold": {
    "Description": "The Naor-Reingold psuedorandom function is a family of cryprographic PRNGs with hardness reducible to the discrete logarithm problem. A prime (p) is chosen to be the size of the group. Then another prime (q) is chosen which must be a factor of p-1. A third number (g) is chosen to be a generating element that has order q in the ring F_p, meaning that g^q = p+1. Finally an arbitrary array of integers is chosen. In order to generate values the bits of a counter are used, starting at one, to select values in the array. These are multiplied together to get a value (e) and then g^e is calculated and the remainder taken after divided by p. Because computing each value requires several multiplication and divisions it is very slow compared to stream cipher based PRNGs that are used to generate cryptographic random numbers in practice. This implementation uses 64-bit integers for simplicity but a secure version requires at least a few hundred bits to make computing the hidden values impractical for all attackers.",
    "Authors": "Moni Naor and Omer Reingold",
    "Publication": "1997",
    "Traits": [
      "Cryptographic"
    ]
  },
  "Permuted Congruential Generator": {
    "Description": "A PCG is a linear congruential generator combined with some non-linear transformation of the state before it is output. In principle many LCGs and transformations are possible but the ones here are suggested by the original PCG paper. For the same reason the state is always 64 bits and the output is always 32 bits, consequently the increment of the underyling LCG must always be odd.",
    "Authors": "O'Neill",
    "Publication": "2014",
    "Traits": [
      "LCG-based"
    ]
  },
  "RC4": {
    "Description": "The RC4 (Rivest Cipher 4) is a relatively simple stream cipher (and thus PRNG) from 1987, now considered too weak to use. Internally it contains a list of every possible byte and as it runs the list is permuted by swapping positions of bytes. The key is a sequence from 1 to 256 bytes that used to permute the list initially.",
    "Authors": "Rivest",
    "Publication": null,
    "Traits": [
      "Stream Cipher",
      "Cryptographic",
      "Broken"
    ]
  },
  "Rule 30": {
    "Description": "Rule 30 is a one dimensional cellular automata that evolves chaotically. It is named for the Wolfram Code that describes it and several rules are equivalent for use a PRNG. Rule 86 produces the mirror image. Rule 135 inverts the bits. Rule 149 produces the mirror image with inverted bits. In practice using Rule 30 and its related automata as PRNGs is slow and not of very high quality compared to algorithms made for the purpose. This Rule 30 based PRNG has a 128 bit state that is set from the bits of a integer. Any column can be \"tapped\" to draw bits from.",
    "Authors": "Stephen Wolfram",
    "Publication": "1983",
    "Traits": null
  },
  "Salsa20": {
    "Description": "Salsa20 is a family of stream ciphers. The recommended variant is Salsa20/20 which uses 20 rounds, though Salsa20/12 and Salsa20/8 using fewer rounds are also believed to be secure while running much faster. This implementation allows Salsa20 to be run with other round counts as well. Currently Salsa20 has been obsoleted by the ChaCha family of stream ciphers.",
    "Authors": "Bernstein",
    "Publication": null,
    "Traits": [
      "Stream Cipher",
      "Cryptographic"
    ]
  },
  "Self Shrinking Generator": {
    "Description": "A self shrinking generator uses a single LFSR to produce an output that is much harder to predict than its normal usage. To produce a bit the generator is stepped twice. If the bits are (1,0) a 0 bit is output, it the pair is (1,1) a 1 bit is output. Otherwise the process is repeated until an output does occur. Other bit patterns can be chosen to give the output but it is necessary",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Shrinking Generator": {
    "Description": "A shrinking generator uses two LFSRs (called A and S) to produce an output that is much harder to predict than a single LFSR. The two of them are stepped forward synchronously. If the S bit is 1 then the A bit is output, whatever it is. If the S bit it 0 then the A bit is discarded and the process repeated until the S bit is 1. If precise and accurate timing for the rate at which bits are output is available then information about the S generator can be determined by an attacker, though because the generators are used to produce sequences of bits it generally is not possible to trivially reconstruct S based on the timing between individual bits of output.",
    "Authors": null,
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Splitmix64": {
    "Description": "Splitmix64 is the default PRNG for the Java programming language. It is simple and passes many statistical test but is not considered a strong PRNG in and of itself. It is commonly used as a keying function for other PRNGS when they are likely to be given a seed with low entropy such as a single 64 bit integer. In particular Splitmix64 can accept a seed of zero, whereas certain high speed PRNGs cannot.",
    "Authors": null,
    "Publication": null,
    "Traits": null
  },
  "TT800": {
    "Description": "TT800 is a prececessor the Mersenne Twister algorithm.",
    "Authors": " Makoto Matsumoto",
    "Publication": 1994,
    "Traits": null
  },
  "VMPC-R": {
    "Description": "The Variably Modified Permutation Composition RNG is based on RC4 cipher but with a more complex key schedule and an output based on the permutation composition function it is named for.",
    "Authors": null,
    "Publication": null,
    "Traits": null
  },
  "WELL": {
    "Description": "The Well Equidistributed Long-period Linear (WELL) family of PRNGs",
    "Authors": "François Panneton, Pierre L'Ecuyer, and Makoto Matsumoto",
    "Publication": 2006,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Weyl Sequence": {
    "Description": "The original Weyl sequence produces real numbers distributed between 0 and 1 by repeatedly adding an irrational number to the current state and taking the fractional part. For the purpose of improving the output of his PRNGs George Marsaglia defined Weyl sequences as incrementing the state by a value and then taking the remainder when divided by some value coprime to the increment. In practice this is done with machine words of 32 or 64 bits so any odd number is accptable.",
    "Authors": "Hermann Weyl and George Marsaglia",
    "Publication": null,
    "Traits": null
  },
  "Xorshift64": {
    "Description": "The xorshift family of PRNGs are among the simplest and fastest useful random number generators, created by George Marsaglia with some extensions explored by Sebastiano Vigna. They produce the next state by XORing the state with a shifted version of itself three times, performing multiple steps of a LFSR. With properly chosen shifts an xorshift PRNG can guarantee that it visits every possible state except zero excactly once before repeating and like an LFSR never enters the zero state unless started there. The model xorshift here has just 64 bits of state for simplicity, larger state is needed for most purposes.",
    "Authors": "George Marsaglia and Sebastiano Vigna",
    "Publication": "2003",
    "Traits": [
      "LFSR-based"
    ]
  },
  "Xorshift": {
    "Description": "The xorshift family of PRNGs are among the simplest and fastest useful random number generators, created by George Marsaglia with some extensions explored by Sebastiano Vigna. They produce the next state by XORing the state with a shifted version of itself three times, performing multiple steps of a LFSR. With properly chosen shifts an xorshift PRNG can guarantee that it visits every possible state except zero excactly once before repeating and like an LFSR never enters the zero state unless started there.",
    "Authors": "George Marsaglia and Sebastiano Vigna",
    "Publication": "2003",
    "Traits": [
      "LFSR-based"
    ]
  },
  "Xorwow": {
    "Description": "Xorwow combines a xorshift PRNG with a Weyl sequence.",
    "Authors": "George Marsaglia",
    "Publication": "2003",
    "Traits": [
      "LFSR-based"
    ]
  },
  "Xoshiro": {
    "Description": "The xoshiro family of PRNGs are inspired by the xorshift family but add an improving step to the output. Calculation by the authors also allows these generators to be jumped ahead in order to quickly produce a large number of indepedent sequences.",
    "Authors": "Sebastiano Vigna",
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  },
  "Xoroshiro": {
    "Description": "The xoroshiro family of PRNGs",
    "Authors": "",
    "Publication": null,
    "Traits": [
      "LFSR-based"
    ]
  }
}