use super::block_cipher::{BCMode, BCPadding, BlockCipher};

const SIGMA: [u64; 6] = [
    0xa09e667f3bcc908b,
    0xb67ae8584caa73b2,
    0xc6ef372fe94f82be,
    0x54ff53a5f1d36f1c,
    0x10e527fade682d1d,
    0xb05688c2b3e6c1fd,
];

const SBOXES: [[u8; 256]; 4] = [
    [
        0x70, 0x82, 0x2c, 0xec, 0xb3, 0x27, 0xc0, 0xe5, 0xe4, 0x85, 0x57, 0x35, 0xea, 0x0c, 0xae,
        0x41, 0x23, 0xef, 0x6b, 0x93, 0x45, 0x19, 0xa5, 0x21, 0xed, 0x0e, 0x4f, 0x4e, 0x1d, 0x65,
        0x92, 0xbd, 0x86, 0xb8, 0xaf, 0x8f, 0x7c, 0xeb, 0x1f, 0xce, 0x3e, 0x30, 0xdc, 0x5f, 0x5e,
        0xc5, 0x0b, 0x1a, 0xa6, 0xe1, 0x39, 0xca, 0xd5, 0x47, 0x5d, 0x3d, 0xd9, 0x01, 0x5a, 0xd6,
        0x51, 0x56, 0x6c, 0x4d, 0x8b, 0x0d, 0x9a, 0x66, 0xfb, 0xcc, 0xb0, 0x2d, 0x74, 0x12, 0x2b,
        0x20, 0xf0, 0xb1, 0x84, 0x99, 0xdf, 0x4c, 0xcb, 0xc2, 0x34, 0x7e, 0x76, 0x05, 0x6d, 0xb7,
        0xa9, 0x31, 0xd1, 0x17, 0x04, 0xd7, 0x14, 0x58, 0x3a, 0x61, 0xde, 0x1b, 0x11, 0x1c, 0x32,
        0x0f, 0x9c, 0x16, 0x53, 0x18, 0xf2, 0x22, 0xfe, 0x44, 0xcf, 0xb2, 0xc3, 0xb5, 0x7a, 0x91,
        0x24, 0x08, 0xe8, 0xa8, 0x60, 0xfc, 0x69, 0x50, 0xaa, 0xd0, 0xa0, 0x7d, 0xa1, 0x89, 0x62,
        0x97, 0x54, 0x5b, 0x1e, 0x95, 0xe0, 0xff, 0x64, 0xd2, 0x10, 0xc4, 0x00, 0x48, 0xa3, 0xf7,
        0x75, 0xdb, 0x8a, 0x03, 0xe6, 0xda, 0x09, 0x3f, 0xdd, 0x94, 0x87, 0x5c, 0x83, 0x02, 0xcd,
        0x4a, 0x90, 0x33, 0x73, 0x67, 0xf6, 0xf3, 0x9d, 0x7f, 0xbf, 0xe2, 0x52, 0x9b, 0xd8, 0x26,
        0xc8, 0x37, 0xc6, 0x3b, 0x81, 0x96, 0x6f, 0x4b, 0x13, 0xbe, 0x63, 0x2e, 0xe9, 0x79, 0xa7,
        0x8c, 0x9f, 0x6e, 0xbc, 0x8e, 0x29, 0xf5, 0xf9, 0xb6, 0x2f, 0xfd, 0xb4, 0x59, 0x78, 0x98,
        0x06, 0x6a, 0xe7, 0x46, 0x71, 0xba, 0xd4, 0x25, 0xab, 0x42, 0x88, 0xa2, 0x8d, 0xfa, 0x72,
        0x07, 0xb9, 0x55, 0xf8, 0xee, 0xac, 0x0a, 0x36, 0x49, 0x2a, 0x68, 0x3c, 0x38, 0xf1, 0xa4,
        0x40, 0x28, 0xd3, 0x7b, 0xbb, 0xc9, 0x43, 0xc1, 0x15, 0xe3, 0xad, 0xf4, 0x77, 0xc7, 0x80,
        0x9e,
    ],
    [
        0xe0, 0x05, 0x58, 0xd9, 0x67, 0x4e, 0x81, 0xcb, 0xc9, 0x0b, 0xae, 0x6a, 0xd5, 0x18, 0x5d,
        0x82, 0x46, 0xdf, 0xd6, 0x27, 0x8a, 0x32, 0x4b, 0x42, 0xdb, 0x1c, 0x9e, 0x9c, 0x3a, 0xca,
        0x25, 0x7b, 0x0d, 0x71, 0x5f, 0x1f, 0xf8, 0xd7, 0x3e, 0x9d, 0x7c, 0x60, 0xb9, 0xbe, 0xbc,
        0x8b, 0x16, 0x34, 0x4d, 0xc3, 0x72, 0x95, 0xab, 0x8e, 0xba, 0x7a, 0xb3, 0x02, 0xb4, 0xad,
        0xa2, 0xac, 0xd8, 0x9a, 0x17, 0x1a, 0x35, 0xcc, 0xf7, 0x99, 0x61, 0x5a, 0xe8, 0x24, 0x56,
        0x40, 0xe1, 0x63, 0x09, 0x33, 0xbf, 0x98, 0x97, 0x85, 0x68, 0xfc, 0xec, 0x0a, 0xda, 0x6f,
        0x53, 0x62, 0xa3, 0x2e, 0x08, 0xaf, 0x28, 0xb0, 0x74, 0xc2, 0xbd, 0x36, 0x22, 0x38, 0x64,
        0x1e, 0x39, 0x2c, 0xa6, 0x30, 0xe5, 0x44, 0xfd, 0x88, 0x9f, 0x65, 0x87, 0x6b, 0xf4, 0x23,
        0x48, 0x10, 0xd1, 0x51, 0xc0, 0xf9, 0xd2, 0xa0, 0x55, 0xa1, 0x41, 0xfa, 0x43, 0x13, 0xc4,
        0x2f, 0xa8, 0xb6, 0x3c, 0x2b, 0xc1, 0xff, 0xc8, 0xa5, 0x20, 0x89, 0x00, 0x90, 0x47, 0xef,
        0xea, 0xb7, 0x15, 0x06, 0xcd, 0xb5, 0x12, 0x7e, 0xbb, 0x29, 0x0f, 0xb8, 0x07, 0x04, 0x9b,
        0x94, 0x21, 0x66, 0xe6, 0xce, 0xed, 0xe7, 0x3b, 0xfe, 0x7f, 0xc5, 0xa4, 0x37, 0xb1, 0x4c,
        0x91, 0x6e, 0x8d, 0x76, 0x03, 0x2d, 0xde, 0x96, 0x26, 0x7d, 0xc6, 0x5c, 0xd3, 0xf2, 0x4f,
        0x19, 0x3f, 0xdc, 0x79, 0x1d, 0x52, 0xeb, 0xf3, 0x6d, 0x5e, 0xfb, 0x69, 0xb2, 0xf0, 0x31,
        0x0c, 0xd4, 0xcf, 0x8c, 0xe2, 0x75, 0xa9, 0x4a, 0x57, 0x84, 0x11, 0x45, 0x1b, 0xf5, 0xe4,
        0x0e, 0x73, 0xaa, 0xf1, 0xdd, 0x59, 0x14, 0x6c, 0x92, 0x54, 0xd0, 0x78, 0x70, 0xe3, 0x49,
        0x80, 0x50, 0xa7, 0xf6, 0x77, 0x93, 0x86, 0x83, 0x2a, 0xc7, 0x5b, 0xe9, 0xee, 0x8f, 0x01,
        0x3d,
    ],
    [
        0x38, 0x41, 0x16, 0x76, 0xd9, 0x93, 0x60, 0xf2, 0x72, 0xc2, 0xab, 0x9a, 0x75, 0x06, 0x57,
        0xa0, 0x91, 0xf7, 0xb5, 0xc9, 0xa2, 0x8c, 0xd2, 0x90, 0xf6, 0x07, 0xa7, 0x27, 0x8e, 0xb2,
        0x49, 0xde, 0x43, 0x5c, 0xd7, 0xc7, 0x3e, 0xf5, 0x8f, 0x67, 0x1f, 0x18, 0x6e, 0xaf, 0x2f,
        0xe2, 0x85, 0x0d, 0x53, 0xf0, 0x9c, 0x65, 0xea, 0xa3, 0xae, 0x9e, 0xec, 0x80, 0x2d, 0x6b,
        0xa8, 0x2b, 0x36, 0xa6, 0xc5, 0x86, 0x4d, 0x33, 0xfd, 0x66, 0x58, 0x96, 0x3a, 0x09, 0x95,
        0x10, 0x78, 0xd8, 0x42, 0xcc, 0xef, 0x26, 0xe5, 0x61, 0x1a, 0x3f, 0x3b, 0x82, 0xb6, 0xdb,
        0xd4, 0x98, 0xe8, 0x8b, 0x02, 0xeb, 0x0a, 0x2c, 0x1d, 0xb0, 0x6f, 0x8d, 0x88, 0x0e, 0x19,
        0x87, 0x4e, 0x0b, 0xa9, 0x0c, 0x79, 0x11, 0x7f, 0x22, 0xe7, 0x59, 0xe1, 0xda, 0x3d, 0xc8,
        0x12, 0x04, 0x74, 0x54, 0x30, 0x7e, 0xb4, 0x28, 0x55, 0x68, 0x50, 0xbe, 0xd0, 0xc4, 0x31,
        0xcb, 0x2a, 0xad, 0x0f, 0xca, 0x70, 0xff, 0x32, 0x69, 0x08, 0x62, 0x00, 0x24, 0xd1, 0xfb,
        0xba, 0xed, 0x45, 0x81, 0x73, 0x6d, 0x84, 0x9f, 0xee, 0x4a, 0xc3, 0x2e, 0xc1, 0x01, 0xe6,
        0x25, 0x48, 0x99, 0xb9, 0xb3, 0x7b, 0xf9, 0xce, 0xbf, 0xdf, 0x71, 0x29, 0xcd, 0x6c, 0x13,
        0x64, 0x9b, 0x63, 0x9d, 0xc0, 0x4b, 0xb7, 0xa5, 0x89, 0x5f, 0xb1, 0x17, 0xf4, 0xbc, 0xd3,
        0x46, 0xcf, 0x37, 0x5e, 0x47, 0x94, 0xfa, 0xfc, 0x5b, 0x97, 0xfe, 0x5a, 0xac, 0x3c, 0x4c,
        0x03, 0x35, 0xf3, 0x23, 0xb8, 0x5d, 0x6a, 0x92, 0xd5, 0x21, 0x44, 0x51, 0xc6, 0x7d, 0x39,
        0x83, 0xdc, 0xaa, 0x7c, 0x77, 0x56, 0x05, 0x1b, 0xa4, 0x15, 0x34, 0x1e, 0x1c, 0xf8, 0x52,
        0x20, 0x14, 0xe9, 0xbd, 0xdd, 0xe4, 0xa1, 0xe0, 0x8a, 0xf1, 0xd6, 0x7a, 0xbb, 0xe3, 0x40,
        0x4f,
    ],
    [
        0x70, 0x2c, 0xb3, 0xc0, 0xe4, 0x57, 0xea, 0xae, 0x23, 0x6b, 0x45, 0xa5, 0xed, 0x4f, 0x1d,
        0x92, 0x86, 0xaf, 0x7c, 0x1f, 0x3e, 0xdc, 0x5e, 0x0b, 0xa6, 0x39, 0xd5, 0x5d, 0xd9, 0x5a,
        0x51, 0x6c, 0x8b, 0x9a, 0xfb, 0xb0, 0x74, 0x2b, 0xf0, 0x84, 0xdf, 0xcb, 0x34, 0x76, 0x6d,
        0xa9, 0xd1, 0x04, 0x14, 0x3a, 0xde, 0x11, 0x32, 0x9c, 0x53, 0xf2, 0xfe, 0xcf, 0xc3, 0x7a,
        0x24, 0xe8, 0x60, 0x69, 0xaa, 0xa0, 0xa1, 0x62, 0x54, 0x1e, 0xe0, 0x64, 0x10, 0x00, 0xa3,
        0x75, 0x8a, 0xe6, 0x09, 0xdd, 0x87, 0x83, 0xcd, 0x90, 0x73, 0xf6, 0x9d, 0xbf, 0x52, 0xd8,
        0xc8, 0xc6, 0x81, 0x6f, 0x13, 0x63, 0xe9, 0xa7, 0x9f, 0xbc, 0x29, 0xf9, 0x2f, 0xb4, 0x78,
        0x06, 0xe7, 0x71, 0xd4, 0xab, 0x88, 0x8d, 0x72, 0xb9, 0xf8, 0xac, 0x36, 0x2a, 0x3c, 0xf1,
        0x40, 0xd3, 0xbb, 0x43, 0x15, 0xad, 0x77, 0x80, 0x82, 0xec, 0x27, 0xe5, 0x85, 0x35, 0x0c,
        0x41, 0xef, 0x93, 0x19, 0x21, 0x0e, 0x4e, 0x65, 0xbd, 0xb8, 0x8f, 0xeb, 0xce, 0x30, 0x5f,
        0xc5, 0x1a, 0xe1, 0xca, 0x47, 0x3d, 0x01, 0xd6, 0x56, 0x4d, 0x0d, 0x66, 0xcc, 0x2d, 0x12,
        0x20, 0xb1, 0x99, 0x4c, 0xc2, 0x7e, 0x05, 0xb7, 0x31, 0x17, 0xd7, 0x58, 0x61, 0x1b, 0x1c,
        0x0f, 0x16, 0x18, 0x22, 0x44, 0xb2, 0xb5, 0x91, 0x08, 0xa8, 0xfc, 0x50, 0xd0, 0x7d, 0x89,
        0x97, 0x5b, 0x95, 0xff, 0xd2, 0xc4, 0x48, 0xf7, 0xdb, 0x03, 0xda, 0x3f, 0x94, 0x5c, 0x02,
        0x4a, 0x33, 0x67, 0xf3, 0x7f, 0xe2, 0x9b, 0x26, 0x37, 0x3b, 0x96, 0x4b, 0xbe, 0x2e, 0x79,
        0x8c, 0x6e, 0x8e, 0xf5, 0xb6, 0xfd, 0x59, 0x98, 0x6a, 0x46, 0xba, 0x25, 0x42, 0xa2, 0xfa,
        0x07, 0x55, 0xee, 0x0a, 0x49, 0x68, 0x38, 0xa4, 0x28, 0x7b, 0xc9, 0xc1, 0xe3, 0xf4, 0xc7,
        0x9e,
    ],
];

fn f(a: u64, k: u64) -> u64 {
    p(s(a ^ k))
}

fn fl(a: u64, k: u64) -> u64 {
    let mut al = (a >> 32) as u32;
    let mut ar = a as u32;
    let kl = (k >> 32) as u32;
    let kr = k as u32;
    ar ^= (al & kl).rotate_left(1);
    al ^= ar | kr;
    (al as u64) << 32 | ar as u64
}

fn fl_inv(a: u64, k: u64) -> u64 {
    let mut al = (a >> 32) as u32;
    let mut ar = a as u32;
    let kl = (k >> 32) as u32;
    let kr = k as u32;
    al ^= ar | kr;
    ar ^= (al & kl).rotate_left(1);
    (al as u64) << 32 | ar as u64
}

fn sbox(a: u8, n: usize) -> u8 {
    SBOXES[n][a as usize]
}

fn s(a: u64) -> u64 {
    let b = a.to_be_bytes();
    u64::from_be_bytes([
        sbox(b[0], 0),
        sbox(b[1], 1),
        sbox(b[2], 2),
        sbox(b[3], 3),
        sbox(b[4], 1),
        sbox(b[5], 2),
        sbox(b[6], 3),
        sbox(b[7], 0),
    ])
}

fn p(a: u64) -> u64 {
    let b = a.to_be_bytes();
    u64::from_be_bytes([
        b[0] ^ b[2] ^ b[3] ^ b[5] ^ b[6] ^ b[7],
        b[0] ^ b[1] ^ b[3] ^ b[4] ^ b[6] ^ b[7],
        b[0] ^ b[1] ^ b[2] ^ b[4] ^ b[5] ^ b[7],
        b[1] ^ b[2] ^ b[3] ^ b[4] ^ b[5] ^ b[6],
        b[0] ^ b[1] ^ b[5] ^ b[6] ^ b[7],
        b[1] ^ b[2] ^ b[4] ^ b[6] ^ b[7],
        b[2] ^ b[3] ^ b[4] ^ b[5] ^ b[7],
        b[0] ^ b[3] ^ b[4] ^ b[5] ^ b[6],
    ])
}

fn create_ka(kl: (u64, u64), kr: (u64, u64)) -> (u64, u64) {
    let mut t0 = kl.0 ^ kr.0;
    let mut t1 = kl.1 ^ kr.1;
    t1 ^= f(t0, SIGMA[0]);
    t0 ^= f(t1, SIGMA[1]);
    t0 ^= kl.0;
    t1 ^= kl.1;
    t1 ^= f(t0, SIGMA[2]);
    t0 ^= f(t1, SIGMA[3]);
    (t0, t1)
}

fn create_kb(kr: (u64, u64), ka: (u64, u64)) -> (u64, u64) {
    let mut t0 = kr.0 ^ ka.0;
    let mut t1 = kr.1 ^ ka.1;
    t1 ^= f(t0, SIGMA[4]);
    t0 ^= f(t1, SIGMA[5]);
    (t0, t1)
}

// Taken from: https://docs.rs/camellia/latest/src/camellia/camellia.rs.html#350
/// Performs rotate left and taking the higher-half of val as if it were a 128 bit value.
fn rotate_left_hi(val: (u64, u64), mut shift: u8) -> u64 {
    if shift >= 64 {
        shift -= 64;
    }

    (val.0 << shift) | (val.1 >> (64 - shift))
}

/// Performs rotate left and taking the lower-half of val as if it were a 128 bit value.
fn rotate_left_lo(val: (u64, u64), mut shift: u8) -> u64 {
    if shift >= 64 {
        shift -= 64;
    }

    (val.0 >> (64 - shift)) | (val.1 << shift)
}

fn key_schedule_26(subkeys: &mut [u64; 26], kl: (u64, u64), ka: (u64, u64)) {
    subkeys[0] = kl.0;
    subkeys[1] = kl.1;
    subkeys[2] = ka.0;
    subkeys[3] = ka.1;

    subkeys[4] = rotate_left_hi(kl, 15);
    subkeys[5] = rotate_left_lo(kl, 15);
    subkeys[6] = rotate_left_hi(ka, 15);
    subkeys[7] = rotate_left_lo(ka, 15);

    subkeys[8] = rotate_left_hi(ka, 30);
    subkeys[9] = rotate_left_lo(ka, 30);

    subkeys[10] = rotate_left_hi(kl, 45);
    subkeys[11] = rotate_left_lo(kl, 45);
    subkeys[12] = rotate_left_hi(ka, 45);

    subkeys[13] = rotate_left_lo(kl, 60);
    subkeys[14] = rotate_left_hi(ka, 60);
    subkeys[15] = rotate_left_lo(ka, 60);

    subkeys[16] = rotate_left_lo(kl, 77);
    subkeys[17] = rotate_left_hi(kl, 77);

    subkeys[18] = rotate_left_lo(kl, 94);
    subkeys[19] = rotate_left_hi(kl, 94);
    subkeys[20] = rotate_left_lo(ka, 94);
    subkeys[21] = rotate_left_hi(ka, 94);

    subkeys[22] = rotate_left_lo(kl, 111);
    subkeys[23] = rotate_left_hi(kl, 111);
    subkeys[24] = rotate_left_lo(ka, 111);
    subkeys[25] = rotate_left_hi(ka, 111);
}

fn key_schedule_34(
    subkeys: &mut [u64; 34],
    kl: (u64, u64),
    kr: (u64, u64),
    ka: (u64, u64),
    kb: (u64, u64),
) {
    subkeys[0] = kl.0;
    subkeys[1] = kl.1;

    subkeys[2] = kb.0;
    subkeys[3] = kb.1;
    subkeys[4] = rotate_left_hi(kr, 15);
    subkeys[5] = rotate_left_lo(kr, 15);
    subkeys[6] = rotate_left_hi(ka, 15);
    subkeys[7] = rotate_left_lo(ka, 15);

    subkeys[8] = rotate_left_hi(kr, 30);
    subkeys[9] = rotate_left_lo(kr, 30);

    subkeys[10] = rotate_left_hi(kb, 30);
    subkeys[11] = rotate_left_lo(kb, 30);
    subkeys[12] = rotate_left_hi(kl, 45);
    subkeys[13] = rotate_left_lo(kl, 45);
    subkeys[14] = rotate_left_hi(ka, 45);
    subkeys[15] = rotate_left_lo(ka, 45);

    subkeys[16] = rotate_left_hi(kl, 60);
    subkeys[17] = rotate_left_lo(kl, 60);

    subkeys[18] = rotate_left_hi(kr, 60);
    subkeys[19] = rotate_left_lo(kr, 60);
    subkeys[20] = rotate_left_hi(kb, 60);
    subkeys[21] = rotate_left_lo(kb, 60);
    subkeys[22] = rotate_left_lo(kl, 77); // this switch in order from hi/lo to lo/hi is not in the specification
    subkeys[23] = rotate_left_hi(kl, 77); // but it does pass the test vectors and is used in reference implementations

    subkeys[24] = rotate_left_lo(ka, 77);
    subkeys[25] = rotate_left_hi(ka, 77);

    subkeys[26] = rotate_left_lo(kr, 94);
    subkeys[27] = rotate_left_hi(kr, 94);
    subkeys[28] = rotate_left_lo(ka, 94);
    subkeys[29] = rotate_left_hi(ka, 94);
    subkeys[30] = rotate_left_lo(kl, 111);
    subkeys[31] = rotate_left_hi(kl, 111);

    subkeys[32] = rotate_left_lo(kb, 111);
    subkeys[33] = rotate_left_hi(kb, 111);
}

macro_rules! build_camellia {
    ($name: ident, $rounds: literal) => {
        pub struct $name {
            pub input_format: utils::byte_formatting::ByteFormat,
            pub output_format: utils::byte_formatting::ByteFormat,
            pub subkeys: [u64; $rounds],
            pub iv: u128,
            pub mode: BCMode,
            pub padding: BCPadding,
        }

        impl Default for $name {
            fn default() -> Self {
                Self {
                    input_format: utils::byte_formatting::ByteFormat::Hex,
                    output_format: utils::byte_formatting::ByteFormat::Hex,
                    subkeys: [0; $rounds],
                    iv: 0,
                    mode: Default::default(),
                    padding: Default::default(),
                }
            }
        }

        crate::block_cipher_builders! {$name}

        impl BlockCipher<16> for $name {
            fn encrypt_block(&self, bytes: &mut [u8]) {
                let mut v = [0, 0];
                utils::byte_formatting::fill_u64s_be(&mut v, bytes);

                let k = self.subkeys;

                // Prewhitening
                v[0] ^= k[0];
                v[1] ^= k[1];

                for i in (2..$rounds - 2).step_by(2) {
                    if i % 8 == 0 {
                        v[0] = fl(v[0], k[i]);
                        v[1] = fl_inv(v[1], k[i + 1]);
                    } else {
                        v[1] ^= f(v[0], k[i]);
                        v[0] ^= f(v[1], k[i + 1]);
                    }
                }

                // Postwhitening
                v[1] ^= k[$rounds - 2];
                v[0] ^= k[$rounds - 1];

                v.swap(0, 1);
                utils::byte_formatting::u64s_to_bytes_be(bytes, &v);
            }

            fn decrypt_block(&self, bytes: &mut [u8]) {
                let mut v = [0, 0];
                utils::byte_formatting::fill_u64s_be(&mut v, bytes);

                let k = self.subkeys;

                // Prewhitening
                v[0] ^= k[$rounds - 2];
                v[1] ^= k[$rounds - 1];

                for i in (2..$rounds - 2).rev().step_by(2) {
                    if (i - 1) % 8 == 0 {
                        v[0] = fl(v[0], k[i]);
                        v[1] = fl_inv(v[1], k[i - 1]);
                    } else {
                        v[1] ^= f(v[0], k[i]);
                        v[0] ^= f(v[1], k[i - 1]);
                    }
                }

                // Postwhitening
                v[1] ^= k[0];
                v[0] ^= k[1];

                v.swap(0, 1);
                utils::byte_formatting::u64s_to_bytes_be(bytes, &v);
            }
        }
    };
}

build_camellia!(Camellia128, 26);
impl Camellia128 {
    pub fn ksa(&mut self, bytes: [u8; 16]) {
        let kl = (
            u64::from_be_bytes(bytes[0..8].try_into().unwrap()),
            u64::from_be_bytes(bytes[8..16].try_into().unwrap()),
        );
        let ka = create_ka(kl, (0, 0));
        key_schedule_26(&mut self.subkeys, kl, ka);
    }

    pub fn with_key(mut self, bytes: [u8; 16]) -> Self {
        self.ksa(bytes);
        self
    }

    pub fn ksa_u64(&mut self, bytes: [u64; 2]) {
        let kl = (bytes[0], bytes[1]);
        let ka = create_ka(kl, (0, 0));
        key_schedule_26(&mut self.subkeys, kl, ka);
    }
}
crate::impl_cipher_for_block_cipher!(Camellia128, 16);
build_camellia!(Camellia192, 34);
impl Camellia192 {
    pub fn ksa(&mut self, bytes: [u8; 24]) {
        let kl = (
            u64::from_be_bytes(bytes[0..8].try_into().unwrap()),
            u64::from_be_bytes(bytes[8..16].try_into().unwrap()),
        );
        let r = u64::from_be_bytes(bytes[16..24].try_into().unwrap());
        let kr = (r, !r);
        let ka = create_ka(kl, kr);
        let kb = create_kb(kr, ka);
        key_schedule_34(&mut self.subkeys, kl, kr, ka, kb);
    }

    pub fn with_key(mut self, bytes: [u8; 24]) -> Self {
        self.ksa(bytes);
        self
    }

    pub fn ksa_u64(&mut self, bytes: [u64; 3]) {
        let kl = (bytes[0], bytes[1]);
        let r = bytes[2];
        let kr = (r, !r);
        let ka = create_ka(kl, kr);
        let kb = create_kb(kr, ka);
        key_schedule_34(&mut self.subkeys, kl, kr, ka, kb);
    }
}
crate::impl_cipher_for_block_cipher!(Camellia192, 16);
build_camellia!(Camellia256, 34);
impl Camellia256 {
    pub fn ksa(&mut self, bytes: [u8; 32]) {
        let kl = (
            u64::from_be_bytes(bytes[0..8].try_into().unwrap()),
            u64::from_be_bytes(bytes[8..16].try_into().unwrap()),
        );
        let kr = (
            u64::from_be_bytes(bytes[16..24].try_into().unwrap()),
            u64::from_be_bytes(bytes[24..32].try_into().unwrap()),
        );
        let ka = create_ka(kl, kr);
        let kb = create_kb(kr, ka);
        key_schedule_34(&mut self.subkeys, kl, kr, ka, kb);
    }

    pub fn with_key(mut self, bytes: [u8; 32]) -> Self {
        self.ksa(bytes);
        self
    }

    pub fn ksa_u64(&mut self, bytes: [u64; 4]) {
        let kl = (bytes[0], bytes[1]);
        let kr = (bytes[2], bytes[3]);
        let ka = create_ka(kl, kr);
        let kb = create_kb(kr, ka);
        key_schedule_34(&mut self.subkeys, kl, kr, ka, kb);
    }
}
crate::impl_cipher_for_block_cipher!(Camellia256, 16);

// test vectors from https://datatracker.ietf.org/doc/rfc3713/
crate::test_block_cipher!(
    Camellia128::default().with_key(
        [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10]
    ), test_128,
    [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10],
    [0x67, 0x67, 0x31, 0x38, 0x54, 0x96, 0x69, 0x73, 0x08, 0x57, 0x06, 0x56, 0x48, 0xea, 0xbe, 0x43];

    Camellia192::default().with_key(
        [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77]
    ), test_192,
    [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10],
    [0xb4, 0x99, 0x34, 0x01, 0xb3, 0xe9, 0x96, 0xf8, 0x4e, 0xe5, 0xce, 0xe7, 0xd7, 0x9b, 0x09, 0xb9];

    Camellia256::default().with_key(
        [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10, 0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff]
    ), test_256,
    [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef, 0xfe, 0xdc, 0xba, 0x98, 0x76, 0x54, 0x32, 0x10],
    [0x9a, 0xcc, 0x23, 0x7d, 0xff, 0x16, 0xd7, 0x6c, 0x20, 0xef, 0x7c, 0x91, 0x9e, 0x3a, 0x75, 0x09];
);
