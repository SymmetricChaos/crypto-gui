use super::block_cipher::{BCMode, BCPadding, BlockCipher};
use utils::byte_formatting::ByteFormat;

const C1: u128 = 0x517cc1b727220a94fe13abe8fa9a6ee0;
const C2: u128 = 0x6db14acc9e21c820ff28b1d5ef5de2b0;
const C3: u128 = 0xdb92371d2126e9700324977504e8c90e;

// Sboxes
// SB[0] is the inverse of SB[2]
// SB[1] is the inverse of SB[3]
const SB: [[u8; 256]; 4] = [
    [
        0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab,
        0x76, 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4,
        0x72, 0xc0, 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71,
        0xd8, 0x31, 0x15, 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2,
        0xeb, 0x27, 0xb2, 0x75, 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6,
        0xb3, 0x29, 0xe3, 0x2f, 0x84, 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb,
        0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf, 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45,
        0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8, 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5,
        0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2, 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44,
        0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73, 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a,
        0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb, 0xe0, 0x32, 0x3a, 0x0a, 0x49,
        0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79, 0xe7, 0xc8, 0x37, 0x6d,
        0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08, 0xba, 0x78, 0x25,
        0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a, 0x70, 0x3e,
        0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e, 0xe1,
        0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf,
        0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb,
        0x16,
    ],
    [
        0xe2, 0x4e, 0x54, 0xfc, 0x94, 0xc2, 0x4a, 0xcc, 0x62, 0x0d, 0x6a, 0x46, 0x3c, 0x4d, 0x8b,
        0xd1, 0x5e, 0xfa, 0x64, 0xcb, 0xb4, 0x97, 0xbe, 0x2b, 0xbc, 0x77, 0x2e, 0x03, 0xd3, 0x19,
        0x59, 0xc1, 0x1d, 0x06, 0x41, 0x6b, 0x55, 0xf0, 0x99, 0x69, 0xea, 0x9c, 0x18, 0xae, 0x63,
        0xdf, 0xe7, 0xbb, 0x00, 0x73, 0x66, 0xfb, 0x96, 0x4c, 0x85, 0xe4, 0x3a, 0x09, 0x45, 0xaa,
        0x0f, 0xee, 0x10, 0xeb, 0x2d, 0x7f, 0xf4, 0x29, 0xac, 0xcf, 0xad, 0x91, 0x8d, 0x78, 0xc8,
        0x95, 0xf9, 0x2f, 0xce, 0xcd, 0x08, 0x7a, 0x88, 0x38, 0x5c, 0x83, 0x2a, 0x28, 0x47, 0xdb,
        0xb8, 0xc7, 0x93, 0xa4, 0x12, 0x53, 0xff, 0x87, 0x0e, 0x31, 0x36, 0x21, 0x58, 0x48, 0x01,
        0x8e, 0x37, 0x74, 0x32, 0xca, 0xe9, 0xb1, 0xb7, 0xab, 0x0c, 0xd7, 0xc4, 0x56, 0x42, 0x26,
        0x07, 0x98, 0x60, 0xd9, 0xb6, 0xb9, 0x11, 0x40, 0xec, 0x20, 0x8c, 0xbd, 0xa0, 0xc9, 0x84,
        0x04, 0x49, 0x23, 0xf1, 0x4f, 0x50, 0x1f, 0x13, 0xdc, 0xd8, 0xc0, 0x9e, 0x57, 0xe3, 0xc3,
        0x7b, 0x65, 0x3b, 0x02, 0x8f, 0x3e, 0xe8, 0x25, 0x92, 0xe5, 0x15, 0xdd, 0xfd, 0x17, 0xa9,
        0xbf, 0xd4, 0x9a, 0x7e, 0xc5, 0x39, 0x67, 0xfe, 0x76, 0x9d, 0x43, 0xa7, 0xe1, 0xd0, 0xf5,
        0x68, 0xf2, 0x1b, 0x34, 0x70, 0x05, 0xa3, 0x8a, 0xd5, 0x79, 0x86, 0xa8, 0x30, 0xc6, 0x51,
        0x4b, 0x1e, 0xa6, 0x27, 0xf6, 0x35, 0xd2, 0x6e, 0x24, 0x16, 0x82, 0x5f, 0xda, 0xe6, 0x75,
        0xa2, 0xef, 0x2c, 0xb2, 0x1c, 0x9f, 0x5d, 0x6f, 0x80, 0x0a, 0x72, 0x44, 0x9b, 0x6c, 0x90,
        0x0b, 0x5b, 0x33, 0x7d, 0x5a, 0x52, 0xf3, 0x61, 0xa1, 0xf7, 0xb0, 0xd6, 0x3f, 0x7c, 0x6d,
        0xed, 0x14, 0xe0, 0xa5, 0x3d, 0x22, 0xb3, 0xf8, 0x89, 0xde, 0x71, 0x1a, 0xaf, 0xba, 0xb5,
        0x81,
    ],
    [
        0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7,
        0xfb, 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde,
        0xe9, 0xcb, 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42,
        0xfa, 0xc3, 0x4e, 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49,
        0x6d, 0x8b, 0xd1, 0x25, 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c,
        0xcc, 0x5d, 0x65, 0xb6, 0x92, 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15,
        0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84, 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7,
        0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06, 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02,
        0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b, 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc,
        0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73, 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad,
        0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e, 0x47, 0xf1, 0x1a, 0x71, 0x1d,
        0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b, 0xfc, 0x56, 0x3e, 0x4b,
        0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4, 0x1f, 0xdd, 0xa8,
        0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f, 0x60, 0x51,
        0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef, 0xa0,
        0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61,
        0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c,
        0x7d,
    ],
    [
        0x30, 0x68, 0x99, 0x1b, 0x87, 0xb9, 0x21, 0x78, 0x50, 0x39, 0xdb, 0xe1, 0x72, 0x09, 0x62,
        0x3c, 0x3e, 0x7e, 0x5e, 0x8e, 0xf1, 0xa0, 0xcc, 0xa3, 0x2a, 0x1d, 0xfb, 0xb6, 0xd6, 0x20,
        0xc4, 0x8d, 0x81, 0x65, 0xf5, 0x89, 0xcb, 0x9d, 0x77, 0xc6, 0x57, 0x43, 0x56, 0x17, 0xd4,
        0x40, 0x1a, 0x4d, 0xc0, 0x63, 0x6c, 0xe3, 0xb7, 0xc8, 0x64, 0x6a, 0x53, 0xaa, 0x38, 0x98,
        0x0c, 0xf4, 0x9b, 0xed, 0x7f, 0x22, 0x76, 0xaf, 0xdd, 0x3a, 0x0b, 0x58, 0x67, 0x88, 0x06,
        0xc3, 0x35, 0x0d, 0x01, 0x8b, 0x8c, 0xc2, 0xe6, 0x5f, 0x02, 0x24, 0x75, 0x93, 0x66, 0x1e,
        0xe5, 0xe2, 0x54, 0xd8, 0x10, 0xce, 0x7a, 0xe8, 0x08, 0x2c, 0x12, 0x97, 0x32, 0xab, 0xb4,
        0x27, 0x0a, 0x23, 0xdf, 0xef, 0xca, 0xd9, 0xb8, 0xfa, 0xdc, 0x31, 0x6b, 0xd1, 0xad, 0x19,
        0x49, 0xbd, 0x51, 0x96, 0xee, 0xe4, 0xa8, 0x41, 0xda, 0xff, 0xcd, 0x55, 0x86, 0x36, 0xbe,
        0x61, 0x52, 0xf8, 0xbb, 0x0e, 0x82, 0x48, 0x69, 0x9a, 0xe0, 0x47, 0x9e, 0x5c, 0x04, 0x4b,
        0x34, 0x15, 0x79, 0x26, 0xa7, 0xde, 0x29, 0xae, 0x92, 0xd7, 0x84, 0xe9, 0xd2, 0xba, 0x5d,
        0xf3, 0xc5, 0xb0, 0xbf, 0xa4, 0x3b, 0x71, 0x44, 0x46, 0x2b, 0xfc, 0xeb, 0x6f, 0xd5, 0xf6,
        0x14, 0xfe, 0x7c, 0x70, 0x5a, 0x7d, 0xfd, 0x2f, 0x18, 0x83, 0x16, 0xa5, 0x91, 0x1f, 0x05,
        0x95, 0x74, 0xa9, 0xc1, 0x5b, 0x4a, 0x85, 0x6d, 0x13, 0x07, 0x4f, 0x4e, 0x45, 0xb2, 0x0f,
        0xc9, 0x1c, 0xa6, 0xbc, 0xec, 0x73, 0x90, 0x7b, 0xcf, 0x59, 0x8f, 0xa1, 0xf9, 0x2d, 0xf2,
        0xb1, 0x00, 0x94, 0x37, 0x9f, 0xd0, 0x2e, 0x9c, 0x6e, 0x28, 0x3f, 0x80, 0xf0, 0x3d, 0xd3,
        0x25, 0x8a, 0xb5, 0xe7, 0x42, 0xb3, 0xc7, 0xea, 0xf7, 0x4c, 0x11, 0x33, 0x03, 0xa2, 0xac,
        0x60,
    ],
];

// Apply the sboxes
fn sl1(x: u128) -> u128 {
    let mut b = x.to_be_bytes();

    for i in (0..16).step_by(4) {
        b[i + 0] = SB[0][b[i + 0] as usize];
        b[i + 1] = SB[1][b[i + 1] as usize];
        b[i + 2] = SB[2][b[i + 2] as usize];
        b[i + 3] = SB[3][b[i + 3] as usize];
    }

    u128::from_be_bytes(b)
}

// Apply the sboxes so as to invert sl1()
fn sl2(x: u128) -> u128 {
    let mut b = x.to_be_bytes();

    for i in (0..16).step_by(4) {
        b[i + 0] = SB[2][b[i + 0] as usize];
        b[i + 1] = SB[3][b[i + 1] as usize];
        b[i + 2] = SB[0][b[i + 2] as usize];
        b[i + 3] = SB[1][b[i + 3] as usize];
    }

    u128::from_be_bytes(b)
}

// Diffusion layer
// This is an involution so that x = a(a(x)) for all inputs
fn a(x: u128) -> u128 {
    let b = x.to_be_bytes();
    let mut out: [u8; 16] = [0; 16];
    out[0] = b[3] ^ b[4] ^ b[6] ^ b[8] ^ b[9] ^ b[13] ^ b[14];
    out[1] = b[2] ^ b[5] ^ b[7] ^ b[8] ^ b[9] ^ b[12] ^ b[15];
    out[2] = b[1] ^ b[4] ^ b[6] ^ b[10] ^ b[11] ^ b[12] ^ b[15];
    out[3] = b[0] ^ b[5] ^ b[7] ^ b[10] ^ b[11] ^ b[13] ^ b[14];
    out[4] = b[0] ^ b[2] ^ b[5] ^ b[8] ^ b[11] ^ b[14] ^ b[15];
    out[5] = b[1] ^ b[3] ^ b[4] ^ b[9] ^ b[10] ^ b[14] ^ b[15];
    out[6] = b[0] ^ b[2] ^ b[7] ^ b[9] ^ b[10] ^ b[12] ^ b[13];
    out[7] = b[1] ^ b[3] ^ b[6] ^ b[8] ^ b[11] ^ b[12] ^ b[13];
    out[8] = b[0] ^ b[1] ^ b[4] ^ b[7] ^ b[10] ^ b[13] ^ b[15];
    out[9] = b[0] ^ b[1] ^ b[5] ^ b[6] ^ b[11] ^ b[12] ^ b[14];
    out[10] = b[2] ^ b[3] ^ b[5] ^ b[6] ^ b[8] ^ b[13] ^ b[15];
    out[11] = b[2] ^ b[3] ^ b[4] ^ b[7] ^ b[9] ^ b[12] ^ b[14];
    out[12] = b[1] ^ b[2] ^ b[6] ^ b[7] ^ b[9] ^ b[11] ^ b[12];
    out[13] = b[0] ^ b[3] ^ b[6] ^ b[7] ^ b[8] ^ b[10] ^ b[13];
    out[14] = b[0] ^ b[3] ^ b[4] ^ b[5] ^ b[9] ^ b[11] ^ b[14];
    out[15] = b[1] ^ b[2] ^ b[4] ^ b[5] ^ b[8] ^ b[10] ^ b[15];
    u128::from_be_bytes(out)
}

fn fo(x: u128, k: u128) -> u128 {
    a(sl1(x ^ k))
}

fn fe(x: u128, k: u128) -> u128 {
    a(sl2(x ^ k))
}

macro_rules! aria {
    ($name: ident, $key_bytes: literal, $rounds: literal, $c1: ident, $c2: ident, $c3: ident) => {
        pub struct $name {
            pub input_format: ByteFormat,
            pub output_format: ByteFormat,
            pub iv: u128,
            pub mode: BCMode,
            pub padding: BCPadding,
            pub subkeys: [u128; 17],
        }

        impl Default for $name {
            fn default() -> Self {
                Self {
                    input_format: ByteFormat::Hex,
                    output_format: ByteFormat::Hex,
                    iv: 0,
                    mode: Default::default(),
                    padding: Default::default(),
                    subkeys: [0; 17],
                }
            }
        }

        impl $name {
            pub fn ksa(&mut self, bytes: [u8; $key_bytes]) {
                let (kl, kr) = if $key_bytes == 16 {
                    (u128::from_be_bytes(bytes[0..16].try_into().unwrap()), 0)
                } else if $key_bytes == 24 {
                    (
                        u128::from_be_bytes(bytes[0..16].try_into().unwrap()),
                        ((u64::from_be_bytes(bytes[16..24].try_into().unwrap()) as u128) << 64),
                    )
                } else {
                    (
                        u128::from_be_bytes(bytes[0..16].try_into().unwrap()),
                        u128::from_be_bytes(bytes[16..32].try_into().unwrap()),
                    )
                };

                let w0 = kl;
                let w1 = fo(w0, $c1) ^ kr;
                let w2 = fe(w1, $c2) ^ w0;
                let w3 = fo(w2, $c3) ^ w1;

                self.subkeys[0] = w0 ^ w1.rotate_right(19);
                self.subkeys[1] = w1 ^ w2.rotate_right(19);
                self.subkeys[2] = w2 ^ w3.rotate_right(19);
                self.subkeys[3] = w0.rotate_right(19) ^ w3;

                self.subkeys[4] = w0 ^ w1.rotate_right(31);
                self.subkeys[5] = w1 ^ w2.rotate_right(31);
                self.subkeys[6] = w2 ^ w3.rotate_right(31);
                self.subkeys[7] = w0.rotate_right(31) ^ w3;

                self.subkeys[8] = w0 ^ w1.rotate_left(61);
                self.subkeys[9] = w1 ^ w2.rotate_left(61);
                self.subkeys[10] = w2 ^ w3.rotate_left(61);
                self.subkeys[11] = w0.rotate_left(61) ^ w3;

                self.subkeys[12] = w0 ^ w1.rotate_left(31);

                // Extra subkeys for 192- and 256-bit keys
                self.subkeys[13] = w1 ^ w2.rotate_left(31);
                self.subkeys[14] = w2 ^ w3.rotate_left(31);

                // Extra subkeys for 256-bit keys
                self.subkeys[15] = w0.rotate_left(31) ^ w3;
                self.subkeys[16] = w0 ^ w1.rotate_left(19);
            }

            pub fn with_key(mut self, bytes: [u8; $key_bytes]) -> Self {
                self.ksa(bytes);
                self
            }

            pub fn ksa_u32(&mut self, key: [u32; $key_bytes / 4]) {
                let mut bytes = [0u8; $key_bytes];
                for i in 0..($key_bytes / 4) {
                    bytes[i..i + 4].copy_from_slice(&key[i].to_be_bytes());
                }
                self.ksa(bytes)
            }

            pub fn with_key_u32(mut self, key: [u32; $key_bytes / 4]) -> Self {
                self.ksa_u32(key);
                self
            }

            pub fn ksa_u64(&mut self, key: [u64; $key_bytes / 8]) {
                let mut bytes = [0u8; $key_bytes];
                for i in 0..($key_bytes / 8) {
                    bytes[i..i + 8].copy_from_slice(&key[i].to_be_bytes());
                }
                self.ksa(bytes)
            }

            pub fn with_key_u64(mut self, key: [u64; $key_bytes / 8]) -> Self {
                self.ksa_u64(key);
                self
            }

            fn double_round_encrypt(&self, mut v: u128, i: usize) -> u128 {
                v = fo(v, self.subkeys[i]);
                v = fe(v, self.subkeys[i + 1]);
                v
            }

            fn double_round_decrypt(&self, mut v: u128, i: usize) -> u128 {
                v = fo(v, a(self.subkeys[$rounds - i]));
                v = fe(v, a(self.subkeys[$rounds - i - 1]));
                v
            }
        }

        impl BlockCipher<16> for $name {
            fn encrypt_block(&self, bytes: &mut [u8]) {
                let mut v = u128::from_be_bytes(bytes.try_into().unwrap());

                // Main rounds
                for i in (0..$rounds - 2).step_by(2) {
                    v = self.double_round_encrypt(v, i);
                }
                // Extra odd round
                v = fo(v, self.subkeys[$rounds - 2]);
                // Final mixing step
                v = sl2(v ^ self.subkeys[$rounds - 1]) ^ self.subkeys[$rounds];

                bytes.copy_from_slice(&v.to_be_bytes());
            }

            fn decrypt_block(&self, bytes: &mut [u8]) {
                let mut v = u128::from_be_bytes(bytes.try_into().unwrap());

                // In the decryption process most keys are modified by passing them through the diffsuion function a()

                v = fo(v, self.subkeys[$rounds]); // Note subkey[$rounds] is not modified
                v = fe(v, a(self.subkeys[$rounds - 1]));

                // Skip the first two rounds already done above
                for i in (2..$rounds - 2).step_by(2) {
                    v = self.double_round_decrypt(v, i);
                }

                // Extra odd round
                v = fo(v, a(self.subkeys[2]));

                // Final mixing step
                v = sl2(v ^ a(self.subkeys[1])) ^ self.subkeys[0]; // Note subkey[0] is not modified

                bytes.copy_from_slice(&v.to_be_bytes());
            }
            crate::block_cipher_getters!();
        }

        crate::block_cipher_builders! {$name, u128}

        crate::impl_cipher_for_block_cipher!($name, 16);
    };
}

aria!(Aria128, 16, 12, C1, C2, C3);
aria!(Aria192, 24, 14, C2, C3, C1);
aria!(Aria256, 32, 16, C3, C1, C2);

crate::test_block_cipher!(
    test_128, Aria128::default().with_key(
        [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f]
    ),
    [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff],
    [0xd7, 0x18, 0xfb, 0xd6, 0xab, 0x64, 0x4c, 0x73, 0x9d, 0xa9, 0x5f, 0x3b, 0xe6, 0x45, 0x17, 0x78];

    test_192, Aria192::default().with_key(
        [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17]
    ),
    [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff],
    [0x26, 0x44, 0x9c, 0x18, 0x05, 0xdb, 0xe7, 0xaa, 0x25, 0xa4, 0x68, 0xce, 0x26, 0x3a, 0x9e, 0x79];

    test_256, Aria256::default().with_key(
        [0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f]
    ),
    [0x00, 0x11, 0x22, 0x33, 0x44, 0x55, 0x66, 0x77, 0x88, 0x99, 0xaa, 0xbb, 0xcc, 0xdd, 0xee, 0xff],
    [0xf9, 0x2b, 0xd7, 0xc7, 0x9f, 0xb7, 0x2e, 0x2f, 0x2b, 0x8f, 0x80, 0xc1, 0x97, 0x2d, 0x24, 0xfc];
);
