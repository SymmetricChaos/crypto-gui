use crate::traits::StatefulHasher;

const R: u128 = 0xE1000000000000000000000000000000;
const BLOCK_LEN: usize = 16;

// Multiplication in the Galois field used for GHASH. Addition in the same is XOR.
// This implementation is not optimized at all because this project seeks clarity not real world use.
pub fn mult_gf(x: u128, y: u128) -> u128 {
    let mut out = 0;
    let mut v = x;
    for i in 0..128 {
        // Take bits of y from the left
        if y >> (127 - i) & 1 == 1 {
            out ^= v
        }
        // Check rightmost bit of v
        if v & 1 == 0 {
            v >>= 1;
        } else {
            v >>= 1;
            v ^= R;
        }
    }
    out
}

// Add the bytes of block to the accumulator (this is XOR in the Galois Field) then multiply by the value h
// This is used to implement Horner's Rule for evaluating a polynomial
pub fn add_mul(acc: &mut u128, block: &[u8], h: u128) {
    for (i, byte) in block.iter().enumerate() {
        *acc ^= (*byte as u128) << (15 - i) * 8
    }
    *acc = mult_gf(*acc, h);
}

#[derive(Debug, Clone)]
pub struct Ghash {
    h: u128,     // usually determined by a cipher
    c: u128,     // constant term, usually determined by a cipher
    ad_len: u64, // how many bytes of input to treat as the additional data
    accumulator: u128,
    bits_taken: u64,
    buffer: Vec<u8>,
}

impl Default for Ghash {
    fn default() -> Self {
        Self {
            h: 0,
            c: 0,
            ad_len: 0,
            accumulator: 0,
            bits_taken: 0,
            buffer: Vec::with_capacity(BLOCK_LEN),
        }
    }
}

impl Ghash {
    pub fn init(h: &[u8], c: &[u8], ad: &[u8]) -> Self {
        let h = u128::from_be_bytes(h.try_into().expect("h must be exactly 16 bytes"));
        let ad_len = (ad.len() as u64) * 8;
        let mut accumulator = 0;
        for block in ad.chunks(16) {
            add_mul(&mut accumulator, block, h);
        }
        Self {
            h,
            c: u128::from_be_bytes(c.try_into().expect("c must be exactly 16 bytes")),
            ad_len,
            accumulator,
            bits_taken: 0,
            buffer: Vec::with_capacity(BLOCK_LEN),
        }
    }
}

impl StatefulHasher for Ghash {
    fn update(&mut self, mut bytes: &[u8]) {
        crate::compression_routine!(self.buffer, bytes, BLOCK_LEN, {
            self.bits_taken += 128;
            add_mul(&mut self.accumulator, &self.buffer, self.h);
        });
    }

    fn finalize(mut self) -> Vec<u8> {
        // Final block
        if !self.buffer.is_empty() {
            self.bits_taken += (self.buffer.len() * 8) as u64;
            add_mul(&mut self.accumulator, &self.buffer, self.h);
        }

        // The length of the AD and CT form the term x^1
        self.accumulator ^= (self.ad_len as u128) << 64;
        self.accumulator ^= self.bits_taken as u128;
        self.accumulator = mult_gf(self.accumulator, self.h);

        // XOR in the constant term, x^0, this is the key when used securely
        self.accumulator ^= self.c;

        self.accumulator.to_be_bytes().into()
    }

    crate::stateful_hash_helpers!();
}

#[cfg(test)]
mod ghash_tests {
    use super::*;

    #[test]
    fn multiply() {
        let z = mult_gf(
            0x0388DACE60B6A392F328C2B971B2FE78,
            0x66E94BD4EF8A2C3B884CFA59CA342B2E,
        );
        assert_eq!(0x5E2EC746917062882C85B0685353DEB7, z);
    }
}

crate::stateful_hash_tests!(
    test1,
    Ghash::init(
        &[0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b, 0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e],
        &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        &[]
    ),
    &[],
    "00000000000000000000000000000000";

    test2,
    Ghash::init(
        &[0x66, 0xe9, 0x4b, 0xd4, 0xef, 0x8a, 0x2c, 0x3b, 0x88, 0x4c, 0xfa, 0x59, 0xca, 0x34, 0x2b, 0x2e],
        &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        &[]
    ),
    &[0x03, 0x88, 0xda, 0xce, 0x60, 0xb6, 0xa3, 0x92, 0xf3, 0x28, 0xc2, 0xb9, 0x71, 0xb2, 0xfe, 0x78],
    "f38cbb1ad69223dcc3457ae5b6b0f885";

    test3,
    Ghash::init(
        &[0xb8, 0x3b, 0x53, 0x37, 0x08, 0xbf, 0x53, 0x5d, 0x0a, 0xa6, 0xe5, 0x29, 0x80, 0xd5, 0x3b, 0x78],
        &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        &[]
    ),
    &[0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91, 0x47, 0x3f, 0x59, 0x85],
    "7f1b32b81b820d02614f8895ac1d4eac";

    test4,
    Ghash::init(
        &[0xb8, 0x3b, 0x53, 0x37, 0x08, 0xbf, 0x53, 0x5d, 0x0a, 0xa6, 0xe5, 0x29, 0x80, 0xd5, 0x3b, 0x78],
        &[0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        &[0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xfe, 0xed, 0xfa, 0xce, 0xde, 0xad, 0xbe, 0xef, 0xab, 0xad, 0xda, 0xd2]
    ),
    &[0x42, 0x83, 0x1e, 0xc2, 0x21, 0x77, 0x74, 0x24, 0x4b, 0x72, 0x21, 0xb7, 0x84, 0xd0, 0xd4, 0x9c, 0xe3, 0xaa, 0x21, 0x2f, 0x2c, 0x02, 0xa4, 0xe0, 0x35, 0xc1, 0x7e, 0x23, 0x29, 0xac, 0xa1, 0x2e, 0x21, 0xd5, 0x14, 0xb2, 0x54, 0x66, 0x93, 0x1c, 0x7d, 0x8f, 0x6a, 0x5a, 0xac, 0x84, 0xaa, 0x05, 0x1b, 0xa3, 0x0b, 0x39, 0x6a, 0x0a, 0xac, 0x97, 0x3d, 0x58, 0xe0, 0x91],
    "698e57f70e6ecc7fd9463b7260a9ae5f";
);
