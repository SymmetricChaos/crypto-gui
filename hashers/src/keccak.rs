use crate::{errors::HasherError, traits::ClassicHasher};
use utils::byte_formatting::ByteFormat;

pub struct KeccackState {
    array: [[u64; 5]; 5],
}

impl KeccackState {
    pub fn new() -> Self {
        Self {
            array: [[0_u64; 5]; 5],
        }
    }
}

impl std::fmt::Display for KeccackState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for x in 0..5 {
            for y in 0..5 {
                write!(f, "{:016x?} ", self.array[y][x]).unwrap();
            }
            write!(f, "\n").unwrap();
        }
        Ok(())
    }
}

// https://chemejon.wordpress.com/2021/12/06/sha-3-explained-in-plain-english/
pub struct Keccak {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
    pub rate: usize, // bit rate, block size
    pub capacity: usize,
    pub output_size: usize,
}

impl Default for Keccak {
    fn default() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }
}

impl Keccak {
    const L: usize = 6;
    const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    const ROTATION_CONSTANTS: [[u32; 5]; 5] = [
        [0, 36, 3, 41, 18],
        [1, 44, 10, 45, 2],
        [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56],
        [27, 20, 39, 8, 14],
    ];

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn sha3_224() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1152,
            capacity: 448,
            output_size: 224,
        }
    }

    pub fn sha3_256() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }

    pub fn sha3_384() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 832,
            capacity: 768,
            output_size: 384,
        }
    }

    pub fn sha3_512() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 576,
            capacity: 1024,
            output_size: 512,
        }
    }

    // Most basic test with option to print out intermediate values
    // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
    pub fn test_blank_permutation(rounds: usize, silent: bool) -> KeccackState {
        let mut state = KeccackState::new();
        for round in 0..rounds {
            if !silent {
                println!("Round {round}\n-----------------------------");
            }

            // Theta
            let mut c = [0; 5];
            for x in 0..5 {
                c[x] = state.array[x][0]
                    ^ state.array[x][1]
                    ^ state.array[x][2]
                    ^ state.array[x][3]
                    ^ state.array[x][4];
            }
            let mut d = [0; 5];
            for x in 0..5 {
                d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
            }
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] ^= d[x]
                }
            }
            if !silent {
                println!("Theta:\n{}\n", state);
            }

            // Rho: Rotate the bits of each word of the array
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] =
                        state.array[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
                }
            }
            if !silent {
                println!("Rho:\n{}\n", state);
            }

            // Pi: shuffle the lanes of the array, can be merged with previous step
            let a = state.array;
            for x in 0..5 {
                for y in 0..5 {
                    // This is a matrix multiplication in disguise
                    let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                    state.array[tx % 5][ty % 5] = a[x][y];
                }
            }
            if !silent {
                println!("Pi:\n{}\n", state);
            }

            // Chi: this is the only non-linear step
            let a = state.array;
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
                }
            }
            if !silent {
                println!("Chi:\n{}\n", state);
            }

            // Iota: xor a round constant into the [0][0] lane
            state.array[0][0] ^= Self::IOTA_CONSTANTS[round];
            if !silent {
                println!("Iota:\n{}\n\n", state);
            }
        }
        state
    }

    pub fn permutation(state: &mut KeccackState, round: usize) {
        // Theta
        let mut c = [0; 5];
        for x in 0..5 {
            c[x] = state.array[x][0]
                ^ state.array[x][1]
                ^ state.array[x][2]
                ^ state.array[x][3]
                ^ state.array[x][4];
        }
        let mut d = [0; 5];
        for x in 0..5 {
            d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
        }
        for x in 0..5 {
            for y in 0..5 {
                state.array[x][y] ^= d[x]
            }
        }

        // Rho: Rotate the bits of each word of the array
        for x in 0..5 {
            for y in 0..5 {
                state.array[x][y] = state.array[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
            }
        }

        // Pi: shuffle the lanes of the array, can easily be merged with previous step
        let a = state.array;
        for x in 0..5 {
            for y in 0..5 {
                // This is a matrix multiplication in disguise
                let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                state.array[tx % 5][ty % 5] = a[x][y];
            }
        }

        // Chi: this is the only non-linear step
        let a = state.array;
        for x in 0..5 {
            for y in 0..5 {
                state.array[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
            }
        }

        // Iota: xor a round constant into the [0][0] lane
        state.array[0][0] ^= Self::IOTA_CONSTANTS[round];
    }

    // Keccak-f
    pub fn permutations(state: &mut KeccackState) {
        for round in 0..Self::ROUNDS {
            Self::permutation(state, round)
        }
    }

    pub fn absorb(state: &mut KeccackState, message: &[u8]) {}
}

impl ClassicHasher for Keccak {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        // Pad with a 1 bit then fill with zeroes and a final 1 bit
        input.push(0x80);
        while input.len() % self.rate != 0 {
            input.push(0x00)
        }
        input.pop();
        input.push(0x01);

        let mut state = KeccackState::new();
        Self::permutations(&mut state);

        todo!()
    }

    fn hash_bytes_from_string(&self, text: &str) -> Result<String, HasherError> {
        let mut bytes = self
            .input_format
            .text_to_bytes(text)
            .map_err(|_| HasherError::general("byte format error"))?;
        let out = self.hash(&mut bytes);
        Ok(self.output_format.byte_slice_to_text(&out))
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test() {
        // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
        assert_eq!(
            format!("{}", Keccak::test_blank_permutation(24, true)).trim_end(),
            "f1258f7940e1dde7 84d5ccf933c0478a d598261ea65aa9ee bd1547306f80494d 8b284e056253d057 \nff97a42d7f8e6fd4 90fee5a0a44647c4 8c5bda0cd6192e76 ad30a6f71b19059c 30935ab7d08ffc64 \neb5aa93f2317d635 a9a6e6260d712103 81a57c16dbcf555f 43b831cd0347c826 01f22f1a11a5569f \n05e5635a21d9ae61 64befef28cc970f2 613670957bc46611 b87c5a554fd00ecb 8c3ee88a1ccf32c8 \n940c7922ae3a2614 1841f924a2c509e4 16f53526e70465c2 75f644e97f30a13b eaf1ff7b5ceca249");
    }
}
