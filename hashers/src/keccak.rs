use crate::{errors::HasherError, traits::ClassicHasher};
use utils::byte_formatting::ByteFormat;

pub fn index_from_coord(x: usize, y: usize) -> usize {
    5 * y + x
}

pub struct KeccackState {
    array: [[u64; 5]; 5],
}

impl KeccackState {
    pub fn new() -> Self {
        Self {
            array: [[0_u64; 5]; 5],
        }
    }
}

impl std::fmt::Display for KeccackState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for x in 0..5 {
            for y in 0..5 {
                write!(f, "{:016x?} ", self.array[y][x]);
            }
            write!(f, "\n");
        }
        Ok(())
    }
}

// https://chemejon.wordpress.com/2021/12/06/sha-3-explained-in-plain-english/
pub struct Keccak {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
    pub rate: usize, // bit rate, block size
    pub capacity: usize,
    pub output_size: usize,
}

impl Default for Keccak {
    fn default() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }
}

impl Keccak {
    const L: usize = 6;
    const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    const ROTATION_CONSTANTS: [[u32; 5]; 5] = [
        [0, 36, 3, 41, 18],
        [1, 44, 10, 45, 2],
        [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56],
        [27, 20, 39, 14, 8],
    ];

    // Rotation constants, alternative
    // const RHO: [u32; 24] = [
    //     1, 3, 6, 10, 15, 21, 28, 36, 45, 55, 2, 14, 27, 41, 56, 8, 25, 43, 62, 18, 39, 61, 20, 44,
    // ];

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn sha3_224() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1152,
            capacity: 448,
            output_size: 224,
        }
    }

    pub fn sha3_256() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }

    pub fn sha3_384() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 832,
            capacity: 768,
            output_size: 384,
        }
    }

    pub fn sha3_512() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 576,
            capacity: 1024,
            output_size: 512,
        }
    }

    // Test vectors with intermediate states
    // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
    pub fn test_blank_permutation(rounds: usize) {
        let mut state = KeccackState::new();
        for round in 0..rounds {
            println!("Round {round}\n-----------------------------");
            // Theta
            let mut c = [0; 5];
            for x in 0..5 {
                c[x] = state.array[x][0]
                    ^ state.array[x][1]
                    ^ state.array[x][2]
                    ^ state.array[x][3]
                    ^ state.array[x][4];
            }
            let mut d = [0; 5];
            for x in 0..5 {
                d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
            }
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] ^= d[x]
                }
            }
            println!("Theta:\n{}\n", state);

            // Rho: Rotate the bits of each word of the array
            // let mut b = [[0_u64; 5]; 5];
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] =
                        state.array[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
                    // This is a matrix multiplication in disguise
                    // let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                    // b[tx % 5][ty % 5] = state.array[x][y]
                }
            }
            println!("Rho:\n{}\n", state);

            // Pi: shuffle the lanes of the array, can be merged with previous step
            let b = state.array;
            for x in 0..5 {
                for y in 0..5 {
                    // This is a matrix multiplication in disguise
                    let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                    state.array[tx % 5][ty % 5] = b[x][y];
                }
            }
            println!("Pi:\n{}\n", state);

            // Chi
            for x in 0..5 {
                for y in 0..5 {
                    state.array[x][y] = b[x][y] ^ (!b[(x + 1) % 5][y] & b[(x + 2) % 5][y])
                }
            }
            println!("Chi:\n{}\n", state);

            // Iota: xor a round constant into the [0][0] lane
            state.array[0][0] ^= Self::IOTA_CONSTANTS[round];
            println!("Iota:\n{}\n\n", state);
        }
    }

    pub fn permutation(state: &mut KeccackState, round: usize) {
        // Theta
        let mut c = [0; 4];
        for x in 0..4 {
            c[x] = state.array[x][0]
                ^ state.array[x][1]
                ^ state.array[x][2]
                ^ state.array[x][3]
                ^ state.array[x][4];
        }
        let mut d = [0; 4];
        for x in 0..4 {
            d[x] = c[(x + 4) % 4] ^ c[(x + 1) % 4].rotate_left(1);
        }
        for x in 0..4 {
            for y in 0..4 {
                state.array[x][y] ^= d[x]
            }
        }

        // Rho and Pi
        let mut b = [[0_u64; 5]; 5];
        for x in 0..4 {
            for y in 0..4 {
                b[y][(2 * x + 3 * y) % 5] =
                    state.array[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y])
            }
        }

        // Chi
        for x in 0..4 {
            for y in 0..4 {
                state.array[x][y] = b[x][y] ^ (!b[(x + 1) % 5][y] & b[(x + 2) % 5][y])
            }
        }

        // Iota
        state.array[0][0] ^= Self::IOTA_CONSTANTS[round];
    }

    // Keccak-f
    pub fn permutations(state: &mut KeccackState) {
        for round in 0..Self::ROUNDS {
            Self::permutation(state, round)
        }
    }

    // pub fn sponge()
}

impl ClassicHasher for Keccak {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        // Pad with a 1 bit then fill with zeroes and a final 1 bit
        input.push(0x80);
        while input.len() % self.rate != 0 {
            input.push(0x00)
        }
        input.pop();
        input.push(0x01);

        let mut state = KeccackState::new();
        Self::permutations(&mut state);

        todo!()
    }

    fn hash_bytes_from_string(&self, text: &str) -> Result<String, HasherError> {
        let mut bytes = self
            .input_format
            .text_to_bytes(text)
            .map_err(|_| HasherError::general("byte format error"))?;
        let out = self.hash(&mut bytes);
        Ok(self.output_format.byte_slice_to_text(&out))
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test_suite() {
        let mut hasher = Keccak::default();
        hasher.input_format = ByteFormat::Hex;
        hasher.output_format = ByteFormat::Hex;
        Keccak::test_blank_permutation(2);
    }
}
