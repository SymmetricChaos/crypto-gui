use utils::byte_formatting::ByteFormat;

use crate::{errors::HasherError, traits::ClassicHasher};

pub struct Keccak {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
}

impl Default for Keccak {
    fn default() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
        }
    }
}

impl Keccak {
    const L: usize = 6;
    const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn theta(state: &mut [u64; 25]) {}
    pub fn rho(state: &mut [u64; 25]) {
        let mut rot = 0;
        for i in 1..26 {
            rot += i as u32;
            state[i] = state[i].rotate_right(rot)
        }
    }
    pub fn pi(state: &mut [u64; 25]) {}
    pub fn chi(state: &mut [u64; 25]) {}
    pub fn iota(state: &mut [u64; 25], round: usize) {
        state[0] ^= Self::IOTA_CONSTANTS[round]
    }

    pub fn permutation(state: &mut [u64; 25]) {
        for round in 0..Self::ROUNDS {
            Self::theta(state);
            Self::rho(state);
            Self::pi(state);
            Self::chi(state);
            Self::iota(state, round);
        }
    }
}

impl ClassicHasher for Keccak {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        let mut state = [0_u64; 25];
        Self::permutation(&mut state);

        todo!()
    }

    fn hash_bytes_from_string(&self, text: &str) -> Result<String, HasherError> {
        let mut bytes = self
            .input_format
            .text_to_bytes(text)
            .map_err(|_| HasherError::general("byte format error"))?;
        let out = self.hash(&mut bytes);
        Ok(self.output_format.byte_slice_to_text(&out))
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test_suite() {
        let mut hasher = Keccak::default();
        hasher.input_format = ByteFormat::Hex;
        hasher.output_format = ByteFormat::Hex;
    }
}
