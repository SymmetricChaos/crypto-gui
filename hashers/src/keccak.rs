use utils::byte_formatting::ByteFormat;

use crate::{errors::HasherError, traits::ClassicHasher};

pub fn index_from_coord(x: usize, y: usize) -> usize {
    5 * y + x
}

// https://chemejon.wordpress.com/2021/12/06/sha-3-explained-in-plain-english/
pub struct Keccak {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
    pub rate: usize, // bit rate, block size
    pub capacity: usize,
    pub output_size: usize,
}

impl Default for Keccak {
    fn default() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }
}

impl Keccak {
    const L: usize = 6;
    const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn sha3_224() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1152,
            capacity: 448,
            output_size: 224,
        }
    }

    pub fn sha3_256() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }

    pub fn sha3_384() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 832,
            capacity: 768,
            output_size: 384,
        }
    }

    pub fn sha3_512() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 576,
            capacity: 1024,
            output_size: 512,
        }
    }

    fn lane(state: &mut [u64; 25], x: usize, y: usize) -> &mut u64 {
        &mut state[5 * y + x]
    }

    pub fn theta(state: &mut [u64; 25]) {}
    pub fn rho(state: &mut [u64; 25]) {
        let mut rot = 0;
        for i in 1..26 {
            rot += i as u32;
            state[i] = state[i].rotate_right(rot)
        }
    }

    // Algorithm pi rearranges the lines, leaving a fixed point at index 0
    pub fn pi(state: &mut [u64; 25]) {
        let temp = state.clone();
        for x in 0..5 {
            for y in 0..5 {
                let i = index_from_coord(x, y);
                let j = index_from_coord((x + 3 * y) % 5, x);
                state[i] = temp[j];
            }
        }
    }

    pub fn chi(state: &mut [u64; 25]) {}

    // Algorithm iota XORs a constant into the lane at index 0
    pub fn iota(state: &mut [u64; 25], round: usize) {
        state[0] ^= Self::IOTA_CONSTANTS[round]
    }

    pub fn permutation(state: &mut [u64; 25]) {
        for round in 0..Self::ROUNDS {
            Self::theta(state);
            Self::rho(state);
            Self::pi(state);
            Self::chi(state);
            Self::iota(state, round);
        }
    }
}

impl ClassicHasher for Keccak {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        // Pad with a 1 bit then fill with zeroes and a final 1 bit
        input.push(0x80);
        while input.len() % self.rate != 0 {
            input.push(0x00)
        }
        input.pop();
        input.push(0x01);

        let mut state = [0_u64; 25];
        Self::permutation(&mut state);

        todo!()
    }

    fn hash_bytes_from_string(&self, text: &str) -> Result<String, HasherError> {
        let mut bytes = self
            .input_format
            .text_to_bytes(text)
            .map_err(|_| HasherError::general("byte format error"))?;
        let out = self.hash(&mut bytes);
        Ok(self.output_format.byte_slice_to_text(&out))
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test_suite() {
        let mut hasher = Keccak::default();
        hasher.input_format = ByteFormat::Hex;
        hasher.output_format = ByteFormat::Hex;
    }
}
