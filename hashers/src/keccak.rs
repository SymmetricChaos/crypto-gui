use std::ops::{Index, IndexMut};

use crate::{errors::HasherError, traits::ClassicHasher};
use utils::byte_formatting::ByteFormat;

fn bytes_to_u64_le(bytes: &[u8]) -> Vec<u64> {
    assert!(
        bytes.len() % 8 == 0,
        "must have a length that is a multiple of eight bytes"
    );
    let output_len = bytes.len() / 8;
    let mut out = Vec::with_capacity(output_len);

    for i in 0..output_len {
        let mut word_bits: [u8; 8] = Default::default();
        word_bits.copy_from_slice(&bytes[i * 8..i * 8 + 8]);
        out.push(u64::from_le_bytes(word_bits));
    }
    out
}

#[derive(Debug, Clone, Copy)]
pub struct KeccackState {
    array: [[u64; 5]; 5],
}

impl KeccackState {
    pub fn new() -> Self {
        Self {
            array: [[0_u64; 5]; 5],
        }
    }
}

impl Index<usize> for KeccackState {
    type Output = [u64; 5];

    fn index(&self, index: usize) -> &Self::Output {
        &self.array[index]
    }
}

impl IndexMut<usize> for KeccackState {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.array[index]
    }
}

impl std::fmt::Display for KeccackState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for x in 0..5 {
            for y in 0..5 {
                write!(f, "{:016x?} ", self.array[y][x]).unwrap();
            }
            write!(f, "\n").unwrap();
        }
        Ok(())
    }
}

// https://chemejon.wordpress.com/2021/12/06/sha-3-explained-in-plain-english/
pub struct Keccak {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
    pub rate: usize, // bit rate, block size
    pub capacity: usize,
    pub output_size: usize,
}

impl Default for Keccak {
    fn default() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }
}

impl Keccak {
    // const L: usize = 6;
    // const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    const ROTATION_CONSTANTS: [[u32; 5]; 5] = [
        [0, 36, 3, 41, 18],
        [1, 44, 10, 45, 2],
        [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56],
        [27, 20, 39, 8, 14],
    ];

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn sha3_224() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1152,
            capacity: 448,
            output_size: 224,
        }
    }

    pub fn sha3_256() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 1088,
            capacity: 512,
            output_size: 256,
        }
    }

    pub fn sha3_384() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 832,
            capacity: 768,
            output_size: 384,
        }
    }

    pub fn sha3_512() -> Self {
        Self {
            input_format: ByteFormat::Hex,
            output_format: ByteFormat::Hex,
            rate: 576,
            capacity: 1024,
            output_size: 512,
        }
    }

    // Most basic test with option to print out intermediate values
    // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
    pub fn test_blank_permutation(rounds: usize, silent: bool) -> KeccackState {
        let mut state = KeccackState::new();
        for round in 0..rounds {
            if !silent {
                println!("Round {round}\n-----------------------------");
            }

            // Theta
            let mut c = [0; 5];
            for x in 0..5 {
                c[x] = state[x][0] ^ state[x][1] ^ state[x][2] ^ state[x][3] ^ state[x][4];
            }
            let mut d = [0; 5];
            for x in 0..5 {
                d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
            }
            for x in 0..5 {
                for y in 0..5 {
                    state[x][y] ^= d[x]
                }
            }
            if !silent {
                println!("Theta:\n{}\n", state);
            }

            // Rho: Rotate the bits of each word of the array
            for x in 0..5 {
                for y in 0..5 {
                    state[x][y] = state[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
                }
            }
            if !silent {
                println!("Rho:\n{}\n", state);
            }

            // Pi: shuffle the lanes of the array, can be merged with previous step
            let a = state.clone();
            for x in 0..5 {
                for y in 0..5 {
                    // This is a matrix multiplication in disguise
                    let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                    state[tx % 5][ty % 5] = a[x][y];
                }
            }
            if !silent {
                println!("Pi:\n{}\n", state);
            }

            // Chi: this is the only non-linear step
            let a = state;
            for x in 0..5 {
                for y in 0..5 {
                    state[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
                }
            }
            if !silent {
                println!("Chi:\n{}\n", state);
            }

            // Iota: xor a round constant into the [0][0] lane
            state[0][0] ^= Self::IOTA_CONSTANTS[round];
            if !silent {
                println!("Iota:\n{}\n\n", state);
            }
        }
        state
    }

    pub fn permutation(state: &mut KeccackState, round: usize) {
        // Theta
        let mut c = [0; 5];
        for x in 0..5 {
            c[x] = state[x][0] ^ state[x][1] ^ state[x][2] ^ state[x][3] ^ state[x][4];
        }
        let mut d = [0; 5];
        for x in 0..5 {
            d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
        }
        for x in 0..5 {
            for y in 0..5 {
                state[x][y] ^= d[x]
            }
        }

        // Rho: Rotate the bits of each word of the array
        for x in 0..5 {
            for y in 0..5 {
                state[x][y] = state[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
            }
        }

        // Pi: shuffle the lanes of the array, can easily be merged with previous step
        let a = state.clone();
        for x in 0..5 {
            for y in 0..5 {
                // This is a matrix multiplication in disguise
                let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                state[tx % 5][ty % 5] = a[x][y];
            }
        }

        // Chi: this is the only non-linear step
        let a = state.clone();
        for x in 0..5 {
            for y in 0..5 {
                state[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
            }
        }

        // Iota: xor a round constant into the [0][0] lane
        state[0][0] ^= Self::IOTA_CONSTANTS[round];
    }

    // Keccak-f
    pub fn permutations(state: &mut KeccackState) {
        for round in 0..Self::ROUNDS {
            Self::permutation(state, round)
        }
    }

    pub fn absorb(&self, state: &mut KeccackState, message: &[u8]) {
        let byte_rate = self.rate / 8;
        assert!(
            message.len() % byte_rate == 0,
            "message length must be a multiple of byte rate, {}",
            byte_rate
        );

        let n_chunks = message.len() / byte_rate;
        let words = bytes_to_u64_le(message);

        for chunk_i in 0..n_chunks {
            let chunk_offset: usize = chunk_i * (self.rate / 8);
            let mut x = 0;
            let mut y = 0;
            for i in 0..(self.rate / 8) {
                let word = words[chunk_offset + i];
                state[x][y] ^= word;
                // Notice that not all of the state is used during absorb
                // The state size if 1600 bits, 1088 are used for absorbing, and 512 are reserved as capacity
                if x < 5 - 1 {
                    x += 1;
                } else {
                    y += 1;
                    x = 0;
                }
            }
            // At the end of each 1088 bit chunk the state is fully permuted
            Self::permutations(state);
        }
    }

    pub fn squeeze(&self, state: &mut KeccackState) -> Vec<u8> {
        todo!()
    }
}

impl ClassicHasher for Keccak {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        // Pad with a 1 bit then fill with zeroes and a final 1 bit
        input.push(0x80);
        while input.len() % self.rate != 0 {
            input.push(0x00)
        }
        input.pop();
        input.push(0x01);

        let mut state = KeccackState::new();
        self.absorb(&mut state, bytes);
        self.squeeze(&mut state)
    }

    fn hash_bytes_from_string(&self, text: &str) -> Result<String, HasherError> {
        let mut bytes = self
            .input_format
            .text_to_bytes(text)
            .map_err(|_| HasherError::general("byte format error"))?;
        let out = self.hash(&mut bytes);
        Ok(self.output_format.byte_slice_to_text(&out))
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test() {
        // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
        assert_eq!(
            format!("{}", Keccak::test_blank_permutation(24, true)).trim_end(),
            "f1258f7940e1dde7 84d5ccf933c0478a d598261ea65aa9ee bd1547306f80494d 8b284e056253d057 \nff97a42d7f8e6fd4 90fee5a0a44647c4 8c5bda0cd6192e76 ad30a6f71b19059c 30935ab7d08ffc64 \neb5aa93f2317d635 a9a6e6260d712103 81a57c16dbcf555f 43b831cd0347c826 01f22f1a11a5569f \n05e5635a21d9ae61 64befef28cc970f2 613670957bc46611 b87c5a554fd00ecb 8c3ee88a1ccf32c8 \n940c7922ae3a2614 1841f924a2c509e4 16f53526e70465c2 75f644e97f30a13b eaf1ff7b5ceca249");
    }
}
