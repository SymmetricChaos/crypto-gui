use std::ops::{Index, IndexMut};

use crate::traits::ClassicHasher;
use utils::byte_formatting::ByteFormat;

fn bytes_to_u64_le(bytes: &[u8]) -> Vec<u64> {
    assert!(
        bytes.len() % 8 == 0,
        "must have a length that is a multiple of eight bytes"
    );
    let output_len = bytes.len() / 8;
    let mut out = Vec::with_capacity(output_len);

    for i in 0..output_len {
        let mut word_bits: [u8; 8] = Default::default();
        word_bits.copy_from_slice(&bytes[i * 8..i * 8 + 8]);
        out.push(u64::from_le_bytes(word_bits));
    }
    out
}

#[derive(Debug, Clone, Copy)]
pub struct KeccackState {
    array: [[u64; 5]; 5],
}

impl KeccackState {
    pub fn new() -> Self {
        Self {
            array: [[0_u64; 5]; 5],
        }
    }

    // const L: usize = 6;
    // const W: usize = 64; // word size, 2**6
    const ROUNDS: usize = 24; // 12 + 2L

    const ROTATION_CONSTANTS: [[u32; 5]; 5] = [
        [0, 36, 3, 41, 18],
        [1, 44, 10, 45, 2],
        [62, 6, 43, 15, 61],
        [28, 55, 25, 21, 56],
        [27, 20, 39, 8, 14],
    ];

    // Generated by an LFSR
    const IOTA_CONSTANTS: [u64; 24] = [
        0x0000000000000001,
        0x0000000000008082,
        0x800000000000808a,
        0x8000000080008000,
        0x000000000000808b,
        0x0000000080000001,
        0x8000000080008081,
        0x8000000000008009,
        0x000000000000008a,
        0x0000000000000088,
        0x0000000080008009,
        0x000000008000000a,
        0x000000008000808b,
        0x800000000000008b,
        0x8000000000008089,
        0x8000000000008003,
        0x8000000000008002,
        0x8000000000000080,
        0x000000000000800a,
        0x800000008000000a,
        0x8000000080008081,
        0x8000000000008080,
        0x0000000080000001,
        0x8000000080008008,
    ];

    pub fn theta(&mut self) {
        let mut c = [0; 5];
        for x in 0..5 {
            c[x] = self[x][0] ^ self[x][1] ^ self[x][2] ^ self[x][3] ^ self[x][4];
        }
        let mut d = [0; 5];
        for x in 0..5 {
            d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
        }
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] ^= d[x]
            }
        }
    }

    pub fn rho(&mut self) {
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] = self[x][y].rotate_left(Self::ROTATION_CONSTANTS[x][y]);
            }
        }
    }

    pub fn pi(&mut self) {
        let a = self.clone();
        for x in 0..5 {
            for y in 0..5 {
                // This is a matrix multiplication in disguise
                let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                self[tx % 5][ty % 5] = a[x][y];
            }
        }
    }

    pub fn chi(&mut self) {
        let a = self.clone();
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
            }
        }
    }

    pub fn iota(&mut self, round: usize) {
        self[0][0] ^= Self::IOTA_CONSTANTS[round];
    }

    // Intermediate values can be checked by un-commenting the println! lines
    // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
    pub fn round(&mut self, round: usize) {
        //println!("Round {round}\n-----------------------------");
        // Theta
        self.theta();
        // println!("Theta:\n{}\n", state);

        // Rho: Rotate the bits of each word of the array
        self.rho();
        // println!("Rho:\n{}\n", state);

        // Pi: shuffle the lanes of the array, can easily be merged with previous step
        self.pi();
        // println!("Pi:\n{}\n", state);

        // Chi: this is the only non-linear step
        self.chi();
        // println!("Chi:\n{}\n", state);

        // Iota: xor a round constant into the [0][0] lane
        self.iota(round);
        // println!("Iota:\n{}\n", state);
    }

    // Keccak-f[1600]
    pub fn keccak_f(&mut self) {
        for round in 0..Self::ROUNDS {
            self.round(round)
        }
    }

    pub fn absorb(&mut self, message: &[u8], rate: usize) {
        assert!(
            message.len() % rate == 0,
            "message length in bytes must be a multiple of rate in bytes, {}",
            rate
        );

        let n_chunks = message.len() / rate;
        let words = bytes_to_u64_le(message);

        for chunk_i in 0..n_chunks {
            let chunk_offset: usize = chunk_i * (rate / 8);
            let mut x = 0;
            let mut y = 0;
            for i in 0..(rate / 8) {
                let word = words[chunk_offset + i];
                self[x][y] ^= word;
                // Notice that not all of the state is used during absorbing, several words are reserved
                if x < 5 - 1 {
                    x += 1;
                } else {
                    y += 1;
                    x = 0;
                }
            }
            // println!("{}", self);
            // At the end of each chunk the state is fully permuted
            self.keccak_f();
            // println!("{}", self);
        }
    }

    pub fn squeeze(&mut self, rate: usize, output_size: usize) -> Vec<u8> {
        let mut output = Vec::with_capacity(output_size);

        loop {
            let mut ctr = 0;
            'y_loop: for y in 0..5 {
                for x in 0..5 {
                    output.extend_from_slice(&self[x][y].to_le_bytes());
                    if output.len() >= output_size {
                        output.truncate(output_size);
                        return output;
                    }
                    ctr += 8;
                    if ctr >= rate {
                        self.keccak_f();
                        break 'y_loop;
                    }
                }
            }
        }
    }
}

impl Index<usize> for KeccackState {
    type Output = [u64; 5];

    fn index(&self, index: usize) -> &Self::Output {
        &self.array[index]
    }
}

impl IndexMut<usize> for KeccackState {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.array[index]
    }
}

impl std::fmt::Display for KeccackState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for x in 0..5 {
            for y in 0..5 {
                write!(f, "{:016x?} ", self.array[y][x]).unwrap();
            }
            write!(f, "\n").unwrap();
        }
        Ok(())
    }
}

pub enum Domain {
    Sha3,
    Shake,
}

// https://chemejon.wordpress.com/2021/12/06/sha-3-explained-in-plain-english/
pub struct Sha3 {
    pub input_format: ByteFormat,
    pub output_format: ByteFormat,
    pub rate: usize, // rate in bytes, block size
    // capacity: usize,    // reserved portion of state in bytes,
    pub output_size: usize, // output length in bytes, recommended to be half the capacity
    // pub function_name: Vec<u8>,
    // pub customization: Vec<u8>,
    pub domain: Domain,
}

impl Default for Sha3 {
    fn default() -> Self {
        Self::sha3_256()
    }
}

impl Sha3 {
    // For ease of use rate, capacity, and output size are in bytes
    // For ease of comparing to sepcification their they are shown as the length in bits divided by eight
    pub fn sha3_224() -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 1152 / 8,
            // capacity: 448 / 8,
            output_size: 224 / 8,
            domain: Domain::Sha3,
        }
    }

    pub fn sha3_256() -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 1088 / 8,
            // capacity: 512 / 8,
            output_size: 256 / 8,
            domain: Domain::Sha3,
        }
    }

    pub fn sha3_384() -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 832 / 8,
            // capacity: 768 / 8,
            output_size: 384 / 8,
            domain: Domain::Sha3,
        }
    }

    pub fn sha3_512() -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 576 / 8,
            // capacity: 1024 / 8,
            output_size: 512 / 8,
            domain: Domain::Sha3,
        }
    }

    pub fn shake_128(output_size: usize) -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 1344 / 8,
            // capacity: 256 / 8,
            output_size,
            domain: Domain::Shake,
        }
    }

    pub fn shake_256(output_size: usize) -> Self {
        Self {
            input_format: ByteFormat::Utf8,
            output_format: ByteFormat::Hex,
            rate: 1088 / 8,
            // capacity: 512 / 8,
            output_size,
            domain: Domain::Shake,
        }
    }
}

impl ClassicHasher for Sha3 {
    fn hash(&self, bytes: &[u8]) -> Vec<u8> {
        let mut input = bytes.to_vec();

        // Padding rules taken from NIST FIPS-202
        // https://nvlpubs.nist.gov/nistpubs/FIPS/NIST.FIPS.202.pdf
        // This will never be zero since. Notably if the input length is equal to the rate we push an entire extra block
        let padding_len = self.rate - (input.len() % self.rate);

        if padding_len == 1 {
            match self.domain {
                Domain::Sha3 => input.push(0x86),
                Domain::Shake => input.push(0x9f),
            }
        } else {
            match self.domain {
                Domain::Sha3 => input.push(0x06),
                Domain::Shake => input.push(0x1f),
            }
            input.extend(vec![0x00; padding_len - 2]);
            input.push(0x80)
        }

        let mut state = KeccackState::new();
        state.absorb(&input, self.rate);
        state.squeeze(self.rate, self.output_size)
    }

    crate::hash_bytes_from_string! {}
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test_permutation() {
        // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
        let mut state = KeccackState::new();
        state.keccak_f();
        assert_eq!(
            format!("{}", state).trim_end(),
            "f1258f7940e1dde7 84d5ccf933c0478a d598261ea65aa9ee bd1547306f80494d 8b284e056253d057 \nff97a42d7f8e6fd4 90fee5a0a44647c4 8c5bda0cd6192e76 ad30a6f71b19059c 30935ab7d08ffc64 \neb5aa93f2317d635 a9a6e6260d712103 81a57c16dbcf555f 43b831cd0347c826 01f22f1a11a5569f \n05e5635a21d9ae61 64befef28cc970f2 613670957bc46611 b87c5a554fd00ecb 8c3ee88a1ccf32c8 \n940c7922ae3a2614 1841f924a2c509e4 16f53526e70465c2 75f644e97f30a13b eaf1ff7b5ceca249");
        assert_eq!(format!("{:02x?}",state.squeeze(1088 / 8, 512 / 8)), "[e7, dd, e1, 40, 79, 8f, 25, f1, 8a, 47, c0, 33, f9, cc, d5, 84, ee, a9, 5a, a6, 1e, 26, 98, d5, 4d, 49, 80, 6f, 30, 47, 15, bd, 57, d0, 53, 62, 05, 4e, 28, 8b, d4, 6f, 8e, 7f, 2d, a4, 97, ff, c4, 47, 46, a4, a0, e5, fe, 90, 76, 2e, 19, d6, 0c, da, 5b, 8c]")
    }

    #[test]
    fn test_absorb_and_squeeze() {
        // Padded version of an empty input
        let message: [u8; 136] = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
        ];

        let mut state = KeccackState::new();
        state.absorb(&message, 1088 / 8);

        assert_eq!(
            vec![
                0xa7, 0xff, 0xc6, 0xf8, 0xbf, 0x1e, 0xd7, 0x66, 0x51, 0xc1, 0x47, 0x56, 0xa0, 0x61,
                0xd6, 0x62, 0xf5, 0x80, 0xff, 0x4d, 0xe4, 0x3b, 0x49, 0xfa, 0x82, 0xd8, 0x0a, 0x4b,
                0x80, 0xf8, 0x43, 0x4a
            ],
            state.squeeze(1088 / 8, 256 / 8)
        );
    }

    crate::basic_hash_tests!(
        Sha3::sha3_224(), test224, "",
        "6b4e03423667dbb73b6e15454f0eb1abd4597f9a1b078e3f5b5a6bc7";
        Sha3::sha3_256(), test256, "",
        "a7ffc6f8bf1ed76651c14756a061d662f580ff4de43b49fa82d80a4b80f8434a";
        Sha3::sha3_384(), test384, "",
        "0c63a75b845e4f7d01107d852e4c2485c51a50aaaa94fc61995e71bbee983a2ac3713831264adb47fb6bd1e058d5f004";
        Sha3::sha3_512(), test512, "",
        "a69f73cca23a9ac5c8b567dc185a756e97c982164fe25859e0d1dcc1475c80a615b2123af1f5f94c11e3e9402c3ac558f500199d95b6d3e301758586281dcd26";
        Sha3::shake_128(200), testshake128, "",
        "7f9c2ba4e88f827d616045507605853ed73b8093f6efbc88eb1a6eacfa66ef263cb1eea988004b93103cfb0aeefd2a686e01fa4a58e8a3639ca8a1e3f9ae57e235b8cc873c23dc62b8d260169afa2f75ab916a58d974918835d25e6a435085b2badfd6dfaac359a5efbb7bcc4b59d538df9a04302e10c8bc1cbf1a0b3a5120ea17cda7cfad765f5623474d368ccca8af0007cd9f5e4c849f167a580b14aabdefaee7eef47cb0fca9767be1fda69419dfb927e9df07348b196691abaeb580b32def58538b8d23f877";
        Sha3::shake_256(200), testshake256, "",
        "46b9dd2b0ba88d13233b3feb743eeb243fcd52ea62b81b82b50c27646ed5762fd75dc4ddd8c0f200cb05019d67b592f6fc821c49479ab48640292eacb3b7c4be141e96616fb13957692cc7edd0b45ae3dc07223c8e92937bef84bc0eab862853349ec75546f58fb7c2775c38462c5010d846c185c15111e595522a6bcd16cf86f3d122109e3b1fdd943b6aec468a2d621a7c06c6a957c62b54dafc3be87567d677231395f6147293b68ceab7a9e0c58d864e8efde4e1b9a46cbe854713672f5caaae314ed9083dab";
        Sha3::sha3_256(), testmultiblock256_1, "a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3a3",
        "79f38adec5c20307a98ef76e8324afbfd46cfd81b22e3973c65fa1bd9de31787";
        Sha3::sha3_256(), testmultiblock256_2, "83af34279ccb5430febec07a81950d30f4b66f484826afee7456f0071a51e1bbc55570b5cc7ec6f9309c17bf5befdd7c6ba6e968cf218a2b34bd5cf927ab846e38a40bbd81759e9e33381016a755f699df35d660007b5eadf292feefb735207ebf70b5bd17834f7bfa0e16cb219ad4af524ab1ea37334aa66435e5d397fc0a065c411ebbce32c240b90476d307ce802ec82c1c49bc1bec48c0675ec2a6c6f3ed3e5b741d13437095707c565e10d8a20b8c20468ff9514fcf31b4249cd82dcee58c0a2af538b291a87e3390d737191a07484a5d3f3fb8c8f15ce056e5e5f8febe5e1fb59d6740980aa06ca8a0c20f5712b4cde5d032e92ab89f0ae1",
        "3298a95cfe59b9d6cab99c36dc1324194c09f97f08944a02d9574bbca3186b41";
    );
}
