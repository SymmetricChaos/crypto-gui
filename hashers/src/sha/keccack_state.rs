use std::ops::{Index, IndexMut};

fn bytes_to_u64s_le(bytes: &[u8]) -> Vec<u64> {
    assert!(
        bytes.len() % 8 == 0,
        "must have a length that is a multiple of eight bytes"
    );
    let output_len = bytes.len() / 8;
    let mut out = Vec::with_capacity(output_len);

    for i in 0..output_len {
        let mut word_bits: [u8; 8] = Default::default();
        word_bits.copy_from_slice(&bytes[(i * 8)..(i * 8 + 8)]);
        out.push(u64::from_le_bytes(word_bits));
    }
    out
}

// Word size constants
const L: usize = 6;
// const W: usize = 1 << L; // 64 bits

// 24 Rounds for SHA3
const ROUNDS: usize = 12 + 2 * L;

const ROTATION_CONSTANTS: [[u32; 5]; 5] = [
    [0, 36, 3, 41, 18],
    [1, 44, 10, 45, 2],
    [62, 6, 43, 15, 61],
    [28, 55, 25, 21, 56],
    [27, 20, 39, 8, 14],
];

// Generated by an LFSR
const IOTA_CONSTANTS: [u64; 24] = [
    0x0000000000000001,
    0x0000000000008082,
    0x800000000000808a,
    0x8000000080008000,
    0x000000000000808b,
    0x0000000080000001,
    0x8000000080008081,
    0x8000000000008009,
    0x000000000000008a,
    0x0000000000000088,
    0x0000000080008009,
    0x000000008000000a,
    0x000000008000808b,
    0x800000000000008b,
    0x8000000000008089,
    0x8000000000008003,
    0x8000000000008002,
    0x8000000000000080,
    0x000000000000800a,
    0x800000008000000a,
    0x8000000080008081,
    0x8000000000008080,
    0x0000000080000001,
    0x8000000080008008,
];

#[derive(Debug, Clone, Copy)]
pub struct KeccackState {
    array: [[u64; 5]; 5],
}

// The Index traits simplify writing the absorbing and squeezing
impl Index<usize> for KeccackState {
    type Output = [u64; 5];

    fn index(&self, index: usize) -> &Self::Output {
        &self.array[index]
    }
}

impl IndexMut<usize> for KeccackState {
    fn index_mut(&mut self, index: usize) -> &mut Self::Output {
        &mut self.array[index]
    }
}

impl std::fmt::Display for KeccackState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        for x in 0..5 {
            for y in 0..5 {
                write!(f, "{:016x?} ", self.array[y][x].to_be()).unwrap();
            }
            write!(f, "\n").unwrap();
        }
        Ok(())
    }
}

impl KeccackState {
    pub fn new() -> Self {
        Self {
            array: [[0_u64; 5]; 5],
        }
    }

    pub fn theta(&mut self) {
        let mut c = [0; 5];
        for x in 0..5 {
            c[x] = self[x][0] ^ self[x][1] ^ self[x][2] ^ self[x][3] ^ self[x][4];
        }
        let mut d = [0; 5];
        for x in 0..5 {
            d[x] = c[(x + 4) % 5] ^ c[(x + 1) % 5].rotate_left(1);
        }
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] ^= d[x]
            }
        }
    }

    pub fn rho(&mut self) {
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] = self[x][y].rotate_left(ROTATION_CONSTANTS[x][y]);
            }
        }
    }

    pub fn pi(&mut self) {
        let a = self.clone();
        for x in 0..5 {
            for y in 0..5 {
                // This is a matrix multiplication in disguise
                let (tx, ty) = (x * 0 + y * 1, 2 * x + 3 * y);
                self[tx % 5][ty % 5] = a[x][y];
            }
        }
    }

    pub fn chi(&mut self) {
        let a = self.clone();
        for x in 0..5 {
            for y in 0..5 {
                self[x][y] = a[x][y] ^ (!a[(x + 1) % 5][y] & a[(x + 2) % 5][y])
            }
        }
    }

    pub fn iota(&mut self, round: usize) {
        self[0][0] ^= IOTA_CONSTANTS[round];
    }

    // Intermediate values can be checked by un-commenting the println! lines
    // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
    pub fn round(&mut self, round: usize) {
        //println!("Round {round}\n-----------------------------");
        // Theta
        self.theta();
        // println!("Theta:\n{}\n", state);

        // Rho: Rotate the bits of each word of the array
        self.rho();
        // println!("Rho:\n{}\n", state);

        // Pi: shuffle the lanes of the array, can easily be merged with previous step
        self.pi();
        // println!("Pi:\n{}\n", state);

        // Chi: this is the only non-linear step
        self.chi();
        // println!("Chi:\n{}\n", state);

        // Iota: xor a round constant into the [0][0] lane
        self.iota(round);
        // println!("Iota:\n{}\n", state);
    }

    // Keccak-f[1600]
    pub fn keccak_f_1600(&mut self) {
        for round in 0..ROUNDS {
            self.round(round)
        }
    }

    pub fn absorb(&mut self, message: &[u8], rate: usize) {
        assert!(
            message.len() % rate == 0,
            "message length in bytes must be a multiple of rate in bytes, {}",
            rate
        );

        let n_chunks = message.len() / rate;
        let words = bytes_to_u64s_le(message);

        for chunk_i in 0..n_chunks {
            let chunk_offset: usize = chunk_i * (rate / 8);
            let mut x = 0;
            let mut y = 0;
            for i in 0..(rate / 8) {
                let word = words[chunk_offset + i];
                self[x][y] ^= word;
                // Notice that not all of the state is used during absorbing, several words are reserved
                if x < 5 - 1 {
                    x += 1;
                } else {
                    y += 1;
                    x = 0;
                }
            }
            // At the end of each chunk the state is fully permuted
            self.keccak_f_1600();
        }
    }

    pub fn squeeze(&mut self, rate: usize, hash_len: usize) -> Vec<u8> {
        let mut output = Vec::with_capacity(hash_len);

        loop {
            let mut ctr = 0;
            'y_loop: for y in 0..5 {
                for x in 0..5 {
                    output.extend_from_slice(&self[x][y].to_le_bytes());
                    if output.len() >= hash_len {
                        output.truncate(hash_len);
                        return output;
                    }
                    ctr += 8;
                    if ctr >= rate {
                        self.keccak_f_1600();
                        break 'y_loop;
                    }
                }
            }
        }
    }
}

#[cfg(test)]
mod keccak_tests {
    use super::*;

    #[test]
    fn test_permutation() {
        // https://github.com/XKCP/XKCP/blob/master/tests/TestVectors/KeccakF-1600-IntermediateValues.txt
        let mut state = KeccackState::new();
        state.keccak_f_1600();
        assert_eq!(
            format!("{}", state).trim_end(),
            "f1258f7940e1dde7 84d5ccf933c0478a d598261ea65aa9ee bd1547306f80494d 8b284e056253d057 \nff97a42d7f8e6fd4 90fee5a0a44647c4 8c5bda0cd6192e76 ad30a6f71b19059c 30935ab7d08ffc64 \neb5aa93f2317d635 a9a6e6260d712103 81a57c16dbcf555f 43b831cd0347c826 01f22f1a11a5569f \n05e5635a21d9ae61 64befef28cc970f2 613670957bc46611 b87c5a554fd00ecb 8c3ee88a1ccf32c8 \n940c7922ae3a2614 1841f924a2c509e4 16f53526e70465c2 75f644e97f30a13b eaf1ff7b5ceca249");
        assert_eq!(format!("{:02x?}",state.squeeze(1088 / 8, 512 / 8)), "[e7, dd, e1, 40, 79, 8f, 25, f1, 8a, 47, c0, 33, f9, cc, d5, 84, ee, a9, 5a, a6, 1e, 26, 98, d5, 4d, 49, 80, 6f, 30, 47, 15, bd, 57, d0, 53, 62, 05, 4e, 28, 8b, d4, 6f, 8e, 7f, 2d, a4, 97, ff, c4, 47, 46, a4, a0, e5, fe, 90, 76, 2e, 19, d6, 0c, da, 5b, 8c]")
    }

    #[test]
    fn test_absorb_and_squeeze() {
        // Padded version of an empty input
        let message: [u8; 136] = [
            0x06, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
            0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
        ];

        let mut state = KeccackState::new();
        state.absorb(&message, 1088 / 8);

        assert_eq!(
            vec![
                0xa7, 0xff, 0xc6, 0xf8, 0xbf, 0x1e, 0xd7, 0x66, 0x51, 0xc1, 0x47, 0x56, 0xa0, 0x61,
                0xd6, 0x62, 0xf5, 0x80, 0xff, 0x4d, 0xe4, 0x3b, 0x49, 0xfa, 0x82, 0xd8, 0x0a, 0x4b,
                0x80, 0xf8, 0x43, 0x4a
            ],
            state.squeeze(1088 / 8, 256 / 8)
        );
    }
}
